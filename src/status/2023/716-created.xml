<item>
   <title>Issue #716 created</title>
   <pubDate>2023-09-20T02:34:13Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/716</link>
   <guid>https://qt4cg.org/@qt4cg/2023/#created-716</guid>
   <description>&lt;div&gt;&lt;p&gt;Generators in XPath&lt;/p&gt;&lt;div class="markup"&gt;&lt;h1&gt;What is a generator?&lt;/h1&gt;
&lt;p&gt;Generators are well known and provided out of the box in many programming languages. Per Wikipedia:&lt;/p&gt;
&lt;p&gt;“In &lt;a href="https://en.wikipedia.org/wiki/Computer_science"&gt;computer science&lt;/a&gt;,  a &lt;strong&gt;generator&lt;/strong&gt; is a &lt;a href="https://en.wikipedia.org/wiki/Subroutine"&gt;routine&lt;/a&gt; that can be used to control the &lt;a href="https://en.wikipedia.org/wiki/Iteration"&gt;iteration&lt;/a&gt; behaviour of a &lt;a href="https://en.wikipedia.org/wiki/Control_flow#Loops"&gt;loop&lt;/a&gt;. All generators are also &lt;a href="https://en.wikipedia.org/wiki/Iterator"&gt;iterators&lt;/a&gt;.&lt;a href="https://en.wikipedia.org/wiki/Generator_(computer_programming)#cite_note-1"&gt;[1]&lt;/a&gt; A generator is very similar to a function that returns an array, in that a generator has parameters, can be called, and generates a sequence of values.
However, instead of building an array containing all the values and returning them all at once, a generator yields the values one at a time, which requires less memory and allows the caller to get started processing the first few values immediately. In short, a generator &lt;em&gt;looks like&lt;/em&gt; a function but &lt;em&gt;behaves like&lt;/em&gt; an &lt;a href="https://en.wikipedia.org/wiki/Iterator"&gt;iterator&lt;/a&gt;.”&lt;/p&gt;
&lt;hr/&gt;
&lt;h1&gt;The goal of this proposal (major use-cases)&lt;/h1&gt;
&lt;p&gt;A generator in XPath should be a tool to easily implement the solutions to the following use-cases:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Processing a huge collection whose members may not all be needed.&lt;br/&gt;
A generator will produce only the next member of the collection and only on demand basis.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Handling a collection containing unknown or infinite number of members.
When requested the next member of the collection the generator will always produce it, if the collection still contains any members. It is the responsibility of the caller to issue only the necessary number of requests for the really needed next members.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;What is achieved in both cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A (next) member is produced only on request. No time is spent on producing all members of the collection.&lt;/li&gt;
&lt;li&gt;A (next) member is produced only on request. No memory is consumed to store all members of the collection.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A good problem that is based on these use-cases is to generate a collection of the first N members that have some wanted properties,  and are generated from other collection(s), when it is not known what the size of the original input collections would be in order for the desired number of N members to be discovered.&lt;/p&gt;
&lt;p&gt;For example: &lt;strong&gt;&lt;em&gt;Produce the first 1 000 000 (1M) prime numbers&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Sometimes we may not even know if N such wanted members actually exist, for example: &lt;strong&gt;&lt;em&gt;Produce the first 2 sequences of 28 prime numbers where &lt;a href="https://en.wikipedia.org/wiki/Primes_in_arithmetic_progression#Largest_known_primes_in_AP"&gt;the primes in each of the sequences form an arithmetic progression&lt;/a&gt;.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h1&gt;The Proposal&lt;/h1&gt;
&lt;p&gt;A generator is defined as (and synonym for):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;let $generator as record
                   (initialized as xs:boolean,
                    endReached as xs:boolean,
                    getCurrent as function(..) as item()*,
                    moveNext as function(..) as .. ,
                    *  ) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A generator is an extensible &lt;a href="https://qt4cg.org/pr/715/xquery-40/xpath-40.html#id-record-test"&gt;&lt;strong&gt;&lt;em&gt;record&lt;/em&gt;&lt;/strong&gt; &lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It has four fixed-named keys, and any other map-keys, as required to hold the internal state of that specific generator.&lt;/p&gt;
&lt;p&gt;Here is the meaning of  the four fixed/named keys:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;initialized&lt;/em&gt;&lt;/strong&gt; is a boolean. When a generator &lt;code&gt;$gen&lt;/code&gt;  is initially instantiated, &lt;code&gt;$gen?initialized&lt;/code&gt; is &lt;code&gt;false()&lt;/code&gt;. Any call to &lt;code&gt;$gen?getCurrent()&lt;/code&gt; raises an error. In order to get the first value of the represented collection, the caller must call &lt;code&gt;$gen?moveNext()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;endReached&lt;/em&gt;&lt;/strong&gt; is a boolean. If after a call to &lt;code&gt;moveNext()&lt;/code&gt; the value of the returned generator's &lt;code&gt;endReached&lt;/code&gt; key is &lt;code&gt;true()&lt;/code&gt; then calling &lt;code&gt;moveNext()&lt;/code&gt; and/or &lt;code&gt;getCurrent()&lt;/code&gt; on this generator raises an error.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;getCurrent&lt;/em&gt;&lt;/strong&gt; is a function of zero arguments. It must only be called if the values of &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;true()&lt;/code&gt; and the value of &lt;code&gt;endReached&lt;/code&gt; is &lt;code&gt;false()&lt;/code&gt;, otherwise an error must be raised. This function produces the current member of the collection after the last call to &lt;code&gt;moveNext&lt;/code&gt;, if this call didn't return a generator whose &lt;code&gt;endReached&lt;/code&gt; value was &lt;code&gt;true()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;moveNext&lt;/em&gt;&lt;/strong&gt;  is a function of zero arguments. When called on a generator whose &lt;code&gt;endReached&lt;/code&gt; value is &lt;code&gt;false()&lt;/code&gt; then it produces the next (state of the) generator. including a possibly &lt;code&gt;true()&lt;/code&gt; value of &lt;code&gt;endReached&lt;/code&gt; and if this value is still &lt;code&gt;false()&lt;/code&gt;, then calling &lt;code&gt;getCurrent()&lt;/code&gt; produces the value of the next member of the collection.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Examples of operations on generators&lt;/h1&gt;
&lt;p&gt;The following examples are written in pseudo-code as at the time of writing there was no available implementation of records. And also, the code for recursion in pure XPath makes any such example longer than necessary for grasping its meaning.&lt;/p&gt;
&lt;h2&gt;The Empty Generator&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;emptyGenerator() {
             map{
                 initialized : true(),
                 endReached: true(),
                 getCurrent: function($this as map(*)) {error()},
                 moveNext: function($this as map(*)) {error()}
                }
              }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Take the first N members of the collection&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;take($gen as generator, $n as xs:integer) as generator
{
  let $gen := if(not($gen?initialized)) then $gen?moveNext()
                      else $gen,
      return
         if( $gen?endReached or $n eq 0) then emptyGenerator()
            else map:put($gen, "moveNext", take($gen?moveNext($gen) ), $n -1  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Skip the first N members from the collection&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;skip($gen as generator, $n as xs:integer) as generator
{
  if($n eq 0) then $gen
     else
     {
         let $gen := if(not($gen?initialized)) then $gen?moveNext()
                       else $gen
           return
             if(not($gen?endReached) then skip($gen?moveNext(), $n -1)
               else $gen
     }             
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Subrange of size N starting at the M-th member&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;subrange($gen as generator, $m as xs:integer, $n as xs:integer) as generator
{
  take(skip($gen, $m -1), $n)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Head of a generator&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;head($gen as generator)
{
  take($gen, 1)?getCurrent()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Tail of a generator&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;tail($gen as generator)
{
  skip($gen, 1)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;At index N&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;at($ind as xs:integer)
{
  subrange($ind, 1)?getCurrent()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;For Each&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;for-each($gen as generator, $fun as function(*))
{
   map:put($gen, "getCurrent", function() { $fun($gen?getCurrent()) }  )                              
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;For Each Pair&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;for-each-pair($gen1 as generator, $gen2 as generator, $fun as function(*))
{
   let $gen1 := if(not($gen1?initialized)) then $gen1?moveNext()
                  else $gen1,
       $gen2 := if(not($gen2?initialized)) then $gen2?moveNext()
                  else $gen2,
    return
      if($gen1?endReached or $gen2?endReached) then map:put($gen1, "endReached", true())
        else map:put(map:put($gen1, "getCurrent", function() { $fun($gen1?getCurrent(), $gen2?getCurrent()) } ) ,
                     "moveNext", function() { for-each-pair(skip($gen1, 1), skip($gen2, 1), $fun)}
                    )                             
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Filter&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;filter($gen as generator, $pred as function(item()*) as xs:boolean)
{
     let $getNextGoodValue := function($gen as map(*), $pred as function(item()*) as xs:boolean)
         {
            let $mapResult := iterate-while(
                                            $gen,
                                            function($gen) { not($pred($gen?getCurrent($gen))) },
                                            function($gen) { $gen?moveNext($gen) }
                                            )   
            return $mapResult?getCurrent($mapResult)                     
         },
       $gen := if($gen?initialized) then $gen 
                      else $gen?moveNext($gen)
        return
          map {
               "initialized": true(),
               "endReached":  $gen?endReached,
               "getCurrent": function($this as map(*)) { $getNextGoodValue($this?inputGen, $pred) },
               "moveNext":   function($this as map(*))
                             {    let $nextGoodValue := $getNextGoodValue($this?inputGen?moveNext($this?inputGen), $pred),
                                      $nextGen := iterate-while(
                                                                $this?inputGen?moveNext($this?inputGen),
                                                                function($gen) { not($pred($gen?getCurrent($gen))) },
                                                                function($gen) { $gen?moveNext($gen) }
                                                                )
                                    return
                                      map {
                                            "initialized": $nextGen?initialized,
                                            "endReached":  $nextGen?endReached,
                                            "getCurrent" : function($x) {$nextGoodValue},
                                            "moveNext" :   $this?moveNext,
                                            "inputGen" :   $nextGen
                                           }
                             },
               "inputGen" : $gen
              }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Here are some other useful functions on generators -- with just their signature and summary&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;concat($gen1 as generator , $gen2 as generator )&lt;/strong&gt; - produces a generator that behaves as &lt;code&gt;$gen1&lt;/code&gt; until &lt;code&gt;$gen1.endReached&lt;/code&gt; becomes &lt;code&gt;true()&lt;/code&gt;,  and then behaves as &lt;code&gt;$gen2&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;append($gen as generator, $value as item()*)&lt;/strong&gt; - produces a generator that behaves as &lt;code&gt;$gen&lt;/code&gt; until &lt;code&gt;$gen.endReached&lt;/code&gt; becomes &lt;code&gt;true()&lt;/code&gt;,  and then as a generator that has only the single value &lt;code&gt;value&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;prepend($gen as generator, $value as item()*)&lt;/strong&gt; - produces a generator whose first value is &lt;code&gt;value&lt;/code&gt; and then behaves as &lt;code&gt;$gen&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;some($gen as generator) as xs:boolean&lt;/strong&gt; - Produces &lt;code&gt;true()&lt;/code&gt; if &lt;code&gt;$gen&lt;/code&gt; has at least one value, and &lt;code&gt;false()&lt;/code&gt; otherwise.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;some($gen as generator, $pred as function(item()*) as xs:boolean) as xs:boolean&lt;/strong&gt; - Produces &lt;code&gt;true()&lt;/code&gt; if &lt;code&gt;$gen&lt;/code&gt; has at least one value for which $pred($thisValue) is true(), and &lt;code&gt;false()&lt;/code&gt; otherwise.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ofType($gen as generator, $type as type)&lt;/strong&gt;  - Produces a new generator from &lt;code&gt;$gen&lt;/code&gt; that contains all values from &lt;code&gt;$gen&lt;/code&gt; of type &lt;code&gt;type&lt;/code&gt; -- for this we need to have added to the language the &lt;strong&gt;type&lt;/strong&gt; object.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;skipWhile($gen as generator, $pred as function(item()*) as xs:boolean)&lt;/strong&gt;  - Produces a new generator from &lt;code&gt;$gen&lt;/code&gt; by skipping all starting values for which &lt;code&gt;$pred($theValue)&lt;/code&gt; is &lt;code&gt;true()&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;takeWhile($gen as generator, $pred as function(item()*) as xs:boolean)&lt;/strong&gt;  - Produces a new generator from &lt;code&gt;$gen&lt;/code&gt; which contains all starting values of &lt;code&gt;$gen&lt;/code&gt; for which &lt;code&gt;$pred($theValue)&lt;/code&gt; is &lt;code&gt;true()&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;toArray($gen as generator)&lt;/strong&gt; - Produces an array that contains all values that are contained in &lt;code&gt;$gen&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;toSequence($gen as generator)&lt;/strong&gt; - Produces a sequence that contains all values that are contained in &lt;code&gt;$gen&lt;/code&gt;. Values of &lt;code&gt;$gen&lt;/code&gt; that are sequences themselves are flattened.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;toMap($gen as generator)&lt;/strong&gt; - If the values in $gen are all key-value pairs, produces a map that contains exactly all the key-value pairs from &lt;code&gt;$gen&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;
&lt;p&gt;These and many other useful functions on generators can and should be added to every generator upon construction.&lt;/p&gt;
&lt;p&gt;Thus, it would be good to have an explicit constructor function for a generator:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;     construct-generator($record as 
                               record( initialized as xs:boolean,
                                       endReached as xs:boolean,
                                       getCurrent as function(..) as item()*,
                                       moveNext as function(..) as .. ,
                                      )
                         ) as generator
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
