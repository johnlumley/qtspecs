<item>
   <title>Issue #583 created</title>
   <pubDate>2023-06-29T14:44:42Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/583</link>
   <guid>https://qt4cg.org/@qt4cg/2023/#created-583</guid>
   <description>&lt;div&gt;&lt;p&gt;(array|map):replace â†’ *:substitute or *:change&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;Some observations:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;array:replace would be more versatile if multiple positions could be specified, rather than just a single position.&lt;/li&gt;
&lt;li&gt;if all positions are selected, the function becomes identical to array:for-each. So perhaps we should scrap array:replace and instead add an optional parameter &lt;code&gt;$positions as xs:integer*&lt;/code&gt; to array:for-each. However, that could be confusing: people might imagine that the items at positions not present in the list are discarded, rather than being returned unchanged in the result. So I propose we don't do that.&lt;/li&gt;
&lt;li&gt;if the function is useful on arrays, then it's also useful on sequences. But &lt;code&gt;fn:replace&lt;/code&gt; does something completely different.&lt;/li&gt;
&lt;li&gt;We have a similar function on maps called &lt;code&gt;map:substitute&lt;/code&gt; (but it's not quite the same, because it processes every entry in the map).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In the interests of alignment, I propose we have three functions:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fn:substitute($input as item()*, $positions as xs:positiveInteger*, $action as function(item()) as item())&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;equivalent to &lt;code&gt;for $it at $pos in $item return if ($pos = $positions) then $action($it) else $it&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;array:substitute($array as array(*), $positions as xs:positiveInteger*, $action as function(item()*) as item()*)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;equivalent to &lt;code&gt;array{for member $it at $pos in $item return if ($pos = $positions) then $action($it) else $it}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map:substitute($map as map(*), $keys as xs:anyAtomicValue*, $action as function(anyAtomicValue, item()*) as item()*)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;For the first two functions, we don't really need to allow the second argument to be omitted, because it would then be equivalent to the corresponding for-each() function. Unfortunately that's not quite true of map:for-each(), because it doesn't return a map. However if you want to do a functional replacement of every entry in a map, it can be done easily enough with&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map:build(map:key-value-pairs($map), function{?key}, function{$action(?value)})&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;so we're not really losing anything.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
