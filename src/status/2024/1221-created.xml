<item>
   <title>Issue #1221 created</title>
   <pubDate>2024-05-17T13:40:14Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/1221</link>
   <guid>https://qt4cg.org/@qt4cg/2024/#created-1221</guid>
   <description>&lt;div&gt;&lt;p&gt;new function - fn:tail-recurse a function to allow users to hand roll their recursion and guarentee tail recursion.&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;Motivation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I as a user of XPath want to write a recursive function.&lt;/li&gt;
&lt;li&gt;I write the function,&lt;/li&gt;
&lt;li&gt;I run it,&lt;/li&gt;
&lt;li&gt;it causes a stack overflow&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I don't believe tail recursion detection is part of the spec thus an implementation may not implement it&lt;/li&gt;
&lt;li&gt;tail recursion detection I suspect is hard, and I suspect there are cases that are tail recursion that an implementation doesnt  detect&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tail recursion is not an uncommon problem in other languages, in imperative languages I would simply implement the algorithm using a 'while' loop, creating the 'body' of the while loop is my problem, but once I've done it, I KNOW that in all implementations my algorithm will be executed tail recursively (imperative code is FULL of loops, stack overloads are not an issue).&lt;/p&gt;
&lt;p&gt;An example&lt;/p&gt;
&lt;p&gt;I want to implement a power function in C# I know how to write it recursively, but C# doesn't support tail recursion, so I have to turn it into a loop. I could do this in an ad hoc way using a while loop, but I could also write the loop once, and then ask the developer to pass in a function that defines the body of the loop&lt;/p&gt;
&lt;p&gt;in C# that function could have the type (i.e. it takes a state and either returns a new state or null, a null would indicte the end of the 'loop')&lt;/p&gt;
&lt;p&gt;&lt;code&gt;State? recurse(State state)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;and the library function that executes it have the signature:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;State TailRecurse&amp;lt;State&amp;gt;(Func&amp;lt;State,State?&amp;gt; f, State state) &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;a complete example of how this would appear in C# would be:
(note C# has a nuance w.r.t. the higher kinded type '?' and so the signature of TailRecurse below is slightly weaker than the one above).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var toPower3 = TailRecursion.Power2(3);
var result = TailRecursion.TailRecurse(toPower3, (0, 2));

Console.WriteLine(result.Value.Item2);

class TailRecursion
{
    // actually we want, but because of a quirk in C# around the '?' higher kinded type we have to write the signature symetrically (I think).
    //public static State TailRecurse&amp;lt;State&amp;gt;(Func&amp;lt;State, State?&amp;gt; f, State state)
    public static State TailRecurse&amp;lt;State&amp;gt;(Func&amp;lt;State?,State?&amp;gt; f, State state)
    {
        while (true)
        {
            var result = f(state);
            if (result == null)
            {
                return state;
            }
            state = result;
        }
    }

    public static Func&amp;lt;(int,int)?,(int,int)?&amp;gt; Power2(int n)
    {
        return powerAndX =&amp;gt;
        {
            if (powerAndX.Value.Item1 &amp;gt; n)
            {
                return null;
            }
            return (powerAndX.Value.Item1 + 1, powerAndX.Value.Item2 * powerAndX.Value.Item2);
        };
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;in XSLT I could write this function&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;xsl:function name="kooks:pow" as="xs:integer"&amp;gt;
    &amp;lt;xsl:param name="x" as ="xs:integer"/&amp;gt;
    &amp;lt;xsl:param name="n" as ="xs:integer"/&amp;gt;
    &amp;lt;xsl:choose&amp;gt;
        &amp;lt;xsl:when test="$n = 0"&amp;gt;
            &amp;lt;xsl:sequence select="$x"/&amp;gt;
        &amp;lt;/xsl:when&amp;gt;
        &amp;lt;xsl:otherwise&amp;gt;
            &amp;lt;xsl:sequence select="$x * kooks:pow($x,$n - 1)"/&amp;gt;
        &amp;lt;/xsl:otherwise&amp;gt;
    &amp;lt;/xsl:choose&amp;gt;
&amp;lt;/xsl:function&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I know its tail recursive, but my environment may not for whatever reason detect it (I would hope it does, but I could be doing something much more complex, that IS tail recursive but the environment simply doesn't see it).&lt;/p&gt;
&lt;p&gt;I can't write a loop in XPath etc, it doesnt exist, so I can't escape like I do in C# or scala, in F# (which also doesnt support while loops), I would have to write a function that I was sure F# detected as tail recursive and then path the 'body' of the while loop as a function.&lt;/p&gt;
&lt;p&gt;in XSLT this could look like this (basically the same as the C# example)&lt;/p&gt;
&lt;p&gt;here the C# signature
&lt;code&gt;State TailRecurse&amp;lt;State&amp;gt;(Func&amp;lt;State,State?&amp;gt; f, State state) &lt;/code&gt;
has been translated by using &lt;code&gt;item()*&lt;/code&gt; for state an &lt;code&gt;array(*)&lt;/code&gt; for State?, where an empty array corresponds to null/none, and an array with 1 element corresponds to 'some' State.&lt;/p&gt;
&lt;p&gt;This function IS tail recursive in a very simple way that I think all implementations would detect as such, and thus (if it does) I can pass any function I like and be confident it is processed tail recursively - I can of course do this now, I use saxon, (even though I'm wrestling with it to detect tail recursion for some bizarre reason which is probably my fault) I think it would ideally be a library function and (using a loop) allow non tail recursive environments to support tail recursion, or allow me to simply do the detection myself.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    &amp;lt;xsl:function name="kooks:tailRecurse"&amp;gt;
        &amp;lt;xsl:param name="unfolder" as="function(item()*) as array(*)"/&amp;gt;
        &amp;lt;xsl:param name="state" as="item()*"/&amp;gt;
        &amp;lt;xsl:variable name="newState" select="$unfolder($state)"/&amp;gt;
        &amp;lt;xsl:choose&amp;gt;
            &amp;lt;!-- loop returns null/none - end of recurstion --&amp;gt;
            &amp;lt;xsl:when test="array:size($newState) = 0"&amp;gt;
                &amp;lt;xsl:sequence select="$state"/&amp;gt;
            &amp;lt;/xsl:when&amp;gt;
            &amp;lt;!-- else, unpack the state and loop again --&amp;gt;
            &amp;lt;xsl:otherwise&amp;gt;
                &amp;lt;xsl:sequence select="kooks:tailRecurse($unfolder,array:get($newState,1))"/&amp;gt;
            &amp;lt;/xsl:otherwise&amp;gt;
        &amp;lt;/xsl:choose&amp;gt;        
    &amp;lt;/xsl:function&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For environments that don't do tail recursion detection, they can simple implement the analogous code to the C# example in their implementation i.e. map it to a while loop.&lt;/p&gt;
&lt;p&gt;In both cases I think this is hopefully trivial for the implementor of the language.&lt;/p&gt;
&lt;p&gt;Here's a complete example, with tailRecurse defined as above, that would guarentee (in an environment that detected it correctly) that any passed function is processed.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:array="http://www.w3.org/2005/xpath-functions/array"
    xmlns:map="http://www.w3.org/2005/xpath-functions/map"
    exclude-result-prefixes="xs"
    version="3.0"
    xmlns:kooks="http://www.kookerella.com"&amp;gt;
    
    &amp;lt;!-- (state -&amp;gt; Maybe state) -&amp;gt; state -&amp;gt; state --&amp;gt; 
    &amp;lt;xsl:function name="kooks:tailRecurse"&amp;gt;
        &amp;lt;xsl:param name="unfolder" as="function(item()*) as array(*)"/&amp;gt;
        &amp;lt;xsl:param name="state" as="item()*"/&amp;gt;
        &amp;lt;xsl:variable name="newState" select="$unfolder($state)"/&amp;gt;
        &amp;lt;xsl:choose&amp;gt;
            &amp;lt;!-- loop returns null/none - end of recurstion --&amp;gt;
            &amp;lt;xsl:when test="array:size($newState) = 0"&amp;gt;
                &amp;lt;xsl:sequence select="$state"/&amp;gt;
            &amp;lt;/xsl:when&amp;gt;
            &amp;lt;!-- else, unpack the state and loop again --&amp;gt;
            &amp;lt;xsl:otherwise&amp;gt;
                &amp;lt;xsl:sequence select="kooks:tailRecurse($unfolder,array:get($newState,1))"/&amp;gt;
            &amp;lt;/xsl:otherwise&amp;gt;
        &amp;lt;/xsl:choose&amp;gt;        
    &amp;lt;/xsl:function&amp;gt;
    
    &amp;lt;xsl:function name="kooks:powUnfolder" as="function(item()*) as array(*)"&amp;gt;
        &amp;lt;xsl:param name="x" as="xs:integer"/&amp;gt;
        &amp;lt;xsl:param name="n" as="xs:integer"/&amp;gt;
        &amp;lt;xsl:sequence select="function($state) {
                if (map:get($state,'power') &amp;gt;= $n)
                (: we're done so return null/none :)
                then array {}
                else
                (: else calculate the next power and loop again :)
                    let $newState := map { 
                        'power': map:get($state,'power') + 1,
                        'result': map:get($state,'result') * $x
                        }
                    return array { $newState }
            }"/&amp;gt;
    &amp;lt;/xsl:function&amp;gt;
    
    &amp;lt;xsl:template match="/"&amp;gt;
        &amp;lt;twoToThePower4&amp;gt;
            &amp;lt;xsl:variable name="seed" select="map { 'power':0,'result':1 }"/&amp;gt;
            &amp;lt;xsl:sequence select="map:get(kooks:tailRecurse(kooks:powUnfolder(2,4),$seed),'result')"/&amp;gt;
        &amp;lt;/twoToThePower4&amp;gt;
    &amp;lt;/xsl:template&amp;gt;    
&amp;lt;/xsl:stylesheet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I suspect these lines are not obvious.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;            &amp;lt;xsl:variable name="seed" select="map { 'power':0,'result':1 }"/&amp;gt;
            &amp;lt;xsl:sequence select="map:get(kooks:tailRecurse(kooks:powUnfolder(2,4),$seed),'result')"/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first line says anything to the power 0 is 1, the second line says, I want the 'result of 2 to the power 4.&lt;/p&gt;
&lt;p&gt;Note its VERY similar to xsl:iterate, but that requires an sequence to drive it, this is just general recursion.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
