<item>
   <title>Issue #1395 created</title>
   <pubDate>2024-08-21T16:57:36Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/1395</link>
   <guid>https://qt4cg.org/@qt4cg/2024/#created-1395</guid>
   <description>&lt;div&gt;&lt;p&gt;Choice item types: subtyping&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;We say: [with the example changed for clarity]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;3.3.2.2 Choice Item Types&lt;/p&gt;
&lt;p&gt;[1] If B is a [choice item type], then A ⊆ B is true if A ⊆ M is true for some item type M among the alternatives of B.&lt;/p&gt;
&lt;p&gt;[2] If A is a [choice item type], then A ⊆ B is true if M ⊆ B is true for every item type M among the alternatives of A.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;Because an [enumeration type] is defined as a choice type of singleton enumerations, these rules have the consequence, for example, that enum("P", "Q") is a subtype of enum("P", "Q", "R").&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Now, the first condition [1] doesn't hold: &lt;code&gt;enum("P", "Q")&lt;/code&gt; is not a subtype of &lt;code&gt;enum("P")&lt;/code&gt;, nor of &lt;code&gt;enum("Q")&lt;/code&gt;, nor of &lt;code&gt;enum("R")&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But the second condition [2] does hold: &lt;code&gt;enum("P")&lt;/code&gt; and &lt;code&gt;enum("Q")&lt;/code&gt; are both subtypes of &lt;code&gt;enum("P", "Q", "R")&lt;/code&gt;, under rule [1].&lt;/p&gt;
&lt;p&gt;So the rules are far from clear when both A and B are choice item types.&lt;/p&gt;
&lt;p&gt;I think it probably needs a combined rule.&lt;/p&gt;
&lt;p&gt;(i) if both A and B are choice item types, then A ⊆ B is true if every item type a among the alternatives of A satisfies a ⊆ b for some item type b among the alternatives of B.&lt;/p&gt;
&lt;p&gt;The existing two rules are really just special cases of that for singleton choices.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
