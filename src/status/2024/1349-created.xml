<item>
   <title>Issue #1349 created</title>
   <pubDate>2024-07-29T20:40:26Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/1349</link>
   <guid>https://qt4cg.org/@qt4cg/2024/#created-1349</guid>
   <description>&lt;div&gt;&lt;p&gt;Nothing&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;In the Data Model we are missing an important concept - the concept of &lt;strong&gt;&lt;em&gt;Nothing&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;It has been believed that the type &lt;code&gt;item()*&lt;/code&gt; is sufficient to express all results that can be produced or expressed in the evaluation of an XPath expression.&lt;/p&gt;
&lt;p&gt;In reality, there are XPath expressions whose result cannot be expressed unambiguously. Consider:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;array:values([ (), 1, (2 to 4), [ 5 ] ])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;According to the &lt;strong&gt;&lt;em&gt;&lt;a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-values"&gt;F&amp;amp;O 4.0 specification&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;, the result must be:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(1, 2, 3, 4, [ 5 ])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;And here the value  of the first array member - &lt;code&gt;()&lt;/code&gt; -  is not returned.&lt;/p&gt;
&lt;p&gt;Thus, in the general case, &lt;code&gt;array:size($ar)&lt;/code&gt; is not equal to &lt;code&gt;count(array:values($ar))&lt;/code&gt;,&lt;/p&gt;
&lt;p&gt;and &lt;code&gt;array:size($ar) - count(array:values($ar))&lt;/code&gt; can be any non-negative integer.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/4d29bed7-f287-465c-90b6-fd431602c94b" alt="image"/&gt;&lt;/p&gt;
&lt;p&gt;At present there isn't a way in XPath to represent the &lt;strong&gt;&lt;em&gt;lack of value&lt;/em&gt;&lt;/strong&gt;. The empty sequence &lt;code&gt;()&lt;/code&gt; &lt;strong&gt;is&lt;/strong&gt; a value and thus using it to represent the &lt;strong&gt;&lt;em&gt;lack of value&lt;/em&gt;&lt;/strong&gt; is wrong. Also, if the &lt;strong&gt;lack of value&lt;/strong&gt; is represented by &lt;code&gt;()&lt;/code&gt; then this is completely lost/destroyed/vanishes when concatenated with other sequences.&lt;/p&gt;
&lt;p&gt;The expression:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;deep-equal([ ], [ () ])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;evaluates to &lt;code&gt;false()&lt;/code&gt;, because the first array-argument has no members (contains &lt;strong&gt;&lt;em&gt;nothing&lt;/em&gt;&lt;/strong&gt;), and the second array-argument has one member - the value &lt;code&gt;()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Thus, &lt;code&gt;()&lt;/code&gt; is not &lt;strong&gt;&lt;em&gt;nothing&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;It is time for us to be able to represent &lt;strong&gt;&lt;em&gt;nothing&lt;/em&gt;&lt;/strong&gt;  in an explicit way.&lt;/p&gt;
&lt;p&gt;We need a type &lt;em&gt;&lt;strong&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt;, or maybe &lt;strong&gt;&lt;em&gt;&lt;code&gt;xs:nothing&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt; that tells us that an expression may not evaluate to any value, even not to &lt;strong&gt;&lt;code&gt;()&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Then we will be able to express correctly the type of a lookup expression as    &lt;strong&gt;item()* | nothing&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
