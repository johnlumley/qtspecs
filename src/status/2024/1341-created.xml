<item>
   <title>Issue #1341 created</title>
   <pubDate>2024-07-22T21:11:13Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/1341</link>
   <guid>https://qt4cg.org/@qt4cg/2024/#created-1341</guid>
   <description>&lt;div&gt;&lt;p&gt;Remove the `$position`  argument from the `$action` function passed to folds&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;&lt;strong&gt;The &lt;code&gt;$position&lt;/code&gt;  argument, passed to the &lt;code&gt;$action&lt;/code&gt;-function-argument of the folds is unnecessary and artificial&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The addition of this argument resulted from the &lt;strong&gt;&lt;em&gt;automatic&lt;/em&gt;&lt;/strong&gt;  adding this position-aware &lt;code&gt;$action&lt;/code&gt;-function-argument to all functions processing sequences and producing result based on their values.&lt;/li&gt;
&lt;li&gt;In doing so, no further analysis was made on the specifics of the fold functions.&lt;/li&gt;
&lt;li&gt;Though this issue has been raised again and again for months, no single and meaningful use-case has been provided.&lt;/li&gt;
&lt;li&gt;This addition departs away from the original meaning of folds as has been well-established by the developers community. Whether or not one needs to produce a variety of folds, such as &lt;em&gt;sum, min, max, average, product, all / none / some / any&lt;/em&gt; - in all these cases the position of the individual items does not matter.&lt;/li&gt;
&lt;li&gt;One bad consequence of this change is that it makes it more difficult for the reader to grasp the meaning of a particular fold-function, and even to wonder if the spec talks about the same fold functions that the reader thought he knew well.&lt;/li&gt;
&lt;li&gt;This change results in unnecessarily complex documentation and testing.&lt;/li&gt;
&lt;li&gt;Users have expressed their dismay over the resulting complexity. To quote @benibela: &lt;a href="https://github.com/qt4cg/qtspecs/pull/1296#issuecomment-2226997813"&gt;"&lt;em&gt;Too many variables make the code hard too read. And the implementation becomes slow, when it has to handle too many arguments. Especially with function coercion adding further type checks&lt;/em&gt;" &lt;/a&gt;.
And @michaelhkay himself: "&lt;em&gt;&lt;a href="https://github.com/qt4cg/qtspecs/pull/1296#issuecomment-2186435979"&gt;I'm inclined to propose dropping the position argument for both fold and scan. It complicates the specification and the use cases are unconvincing. I believe it has been incorrectly specified (for fold-left, the first time $action is called, the value supplied for $pos is 2, whereas for fold-right it is count($input)-1; and the "Error conditions" section talks of $action being applied to 2 arguments). For the -right forms in particular, the semantics are mind-bending enough without introducing this complication.&lt;/a&gt;&lt;/em&gt;"&lt;/li&gt;
&lt;li&gt;It is very easy to make an accidental mistake and pass a 2-arg. &lt;code&gt;$action&lt;/code&gt; function when a 3-arg. function was meant (or the other way around).&lt;/li&gt;
&lt;li&gt;The giant think-tank of Microsoft gives us a good example of a better solution. They never added position-aware overloads to any folds or fold related methods of the Enumerable class. All the following methods do not have position-aware action-function arguments:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href="url"&gt;Aggregate&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.all?view=net-8.0"&gt;All&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.any?view=net-8.0"&gt;Any&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.average?view=net-8.0"&gt;Average&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.first?view=net-8.0"&gt;First&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.firstordefault?view=net-8.0"&gt;FirstOrDefault&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.last?view=net-8.0"&gt;Last&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.lastordefault?view=net-8.0"&gt;LastOrDefault&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.max?view=net-8.0"&gt;Max&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.maxby?view=net-8.0"&gt;MaxBy&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.min?view=net-8.0"&gt;Min&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.minby?view=net-8.0"&gt;MinBy&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.zip?view=net-8.0"&gt;Zip&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This is not an accidental mistake, as Microsoft added to other Enumerable methods overloads that do require position-aware &lt;code&gt;$action&lt;/code&gt;-function arguments:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.select?view=net-8.0#system-linq-enumerable-select-2(system-collections-generic-ienumerable((-0))-system-func((-0-system-int32-1)))"&gt;Select&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.selectmany?view=net-8.0"&gt;SelectMany&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.skipwhile?view=net-8.0"&gt;SkipWhile&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.takewhile?view=net-8.0"&gt;TakeWhile&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.where?view=net-8.0#system-linq-enumerable-where-1(system-collections-generic-ienumerable((-0))-system-func((-0-system-int32-system-boolean)))"&gt;Where&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="10"&gt;
&lt;li&gt;Last and probably most important: &lt;a href="https://github.com/qt4cg/qtspecs/pull/1296#issuecomment-2194049829"&gt;&lt;strong&gt;@michaelhkay gave us a general and an elegant and very readable way&lt;/strong&gt;&lt;/a&gt; of expressing any fold that needs positional information as a 2-step operation where the 1st step creates a map with entries: &lt;code&gt;{"position": $input[$pos]}&lt;/code&gt; and then a fold-operation that only has a non-position-aware &lt;code&gt;$action&lt;/code&gt;-function argument, and has this map as input.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Proposed solution&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Leave the folds unchanged - in order to preserve their original, established meaning and avoid introducing inadequate complexity.&lt;/li&gt;
&lt;li&gt;If deemed really necessary, define separate functions that can take as parameter a position-aware &lt;code&gt;$action&lt;/code&gt;-function.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
