<item>
   <title>Issue #1500 created</title>
   <pubDate>2024-10-16T01:37:44Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/1500</link>
   <guid>https://qt4cg.org/@qt4cg/2024/#created-1500</guid>
   <description>&lt;div&gt;&lt;p&gt;Coupling of global variable-bound maps to character maps in XSLT &lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;In an application I am writing now, the &lt;code&gt;xsl:output-character&lt;/code&gt;s I am writing in my &lt;code&gt;xsl:character-map&lt;/code&gt; are of interest elsewhere in the XSLT complex that is slowly emerging.&lt;/p&gt;
&lt;p&gt;The exercise makes me realize that character maps can be interesting in their own right. We give &lt;code&gt;xsl:character-map&lt;/code&gt;s names, and include them within each other, because they group meaningfully related character-string pairs. Such sets are the sort of thing one might want to have more closely coupled to the XSLT apparatus. For example, someone might create a &lt;code&gt;xsl:character-map&lt;/code&gt; to deal with Unicode characters in a particular script. And those characters are of interest in their own right, and the character selection might engage with other processes that need to interact with those characters.&lt;/p&gt;
&lt;p&gt;What if we were to extend &lt;code&gt;@use-character-maps&lt;/code&gt; to allow character maps to draw from other preexisting maps? The list of &lt;code&gt;eqNames&lt;/code&gt; in &lt;code&gt;@use-character-maps&lt;/code&gt; would be resolved first against names of character maps. For any &lt;code&gt;eqName&lt;/code&gt; that is not the name of a character map, the processor would search for a global variable or global parameter by that name. Any referenced global variable/parameter must be empty or a map. Every key must be castable as a character, and every value must be a string. Failure on any of these points would raise an error.&lt;/p&gt;
&lt;p&gt;Here is an example of hypothetical XSLT code, to illustrate how the innovation might be productively useful, producing two different character maps, each of which might be appropriate for one type of serialization or another:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    &amp;lt;xsl:item-type name="letters:grc" as="record(transliteration as xs:string, name as xs:string)"/&amp;gt;
    &amp;lt;xsl:variable name="master-map" as="map(*)"&amp;gt;
        &amp;lt;xsl:map&amp;gt;
            &amp;lt;xsl:map-entry key="'α'" select="letters:grc('a', 'alpha')"/&amp;gt;
            &amp;lt;xsl:map-entry key="'β'" select="letters:grc('b', 'beta')"/&amp;gt;
        &amp;lt;/xsl:map&amp;gt;
    &amp;lt;/xsl:variable&amp;gt;
    &amp;lt;xsl:variable name="serialization-transliteration-map" as="map(xs:string, xs:string)"&amp;gt;
        &amp;lt;xsl:map&amp;gt;
            &amp;lt;xsl:for-each select="map:keys($master-map)"&amp;gt;
                &amp;lt;xsl:map-entry key="." select="$master-map(current())?transliteration"/&amp;gt;
            &amp;lt;/xsl:for-each&amp;gt;
        &amp;lt;/xsl:map&amp;gt;
    &amp;lt;/xsl:variable&amp;gt;
    &amp;lt;xsl:variable name="serialization-name-map" as="map(xs:string, xs:string)"&amp;gt;
        &amp;lt;xsl:map&amp;gt;
            &amp;lt;xsl:for-each select="map:keys($master-map)"&amp;gt;
                &amp;lt;xsl:map-entry key="." select="$master-map(current())?name"/&amp;gt;
            &amp;lt;/xsl:for-each&amp;gt;
        &amp;lt;/xsl:map&amp;gt;
    &amp;lt;/xsl:variable&amp;gt;
    &amp;lt;xsl:character-map name="transliteration" use-character-maps="serialization-transliteration-map"/&amp;gt;
    &amp;lt;xsl:character-map name="names" use-character-maps="serialization-name-map"/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In other words, if an &lt;code&gt;xsl:character-map&lt;/code&gt; is just a map, why not give it access to other XSLT structures that are maps?&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
