<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><link rel="stylesheet" href="/css/status.css"><title>@qt4cg statuses</title></head><body><main><article><h1>@qt4cg statuses</h1><p>This page displays recent status
            updates
            about the QT4CG project.</p><p>The are also captured in <a href="status.rss">an RSS feed</a>.</p><p>By year: <a href="2024/">2024</a>, <a href="2023/">2023</a>, <a href="2022/">2022</a>, <a href="2021/">2021</a>, <a href="2020/">2020</a></p><div class="toots">
<div class="toot" id="closed-1329"><h2>Issue #1329 closed<span class="toot-id"> #closed-1329</span></h2><div class="pubdate">23 Jul at 16:11:16 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1329">https://github.com/qt4cg/qtspecs/issues/1329</a></div><p>load-xquery-module supplying content</p></div>
<div class="toot" id="closed-1333"><h2>Issue #1333 closed<span class="toot-id"> #closed-1333</span></h2><div class="pubdate">23 Jul at 16:11:15 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1333">https://github.com/qt4cg/qtspecs/pull/1333</a></div><p>1329 Add content option to load-xquery-module</p></div>
<div class="toot" id="closed-1309"><h2>Issue #1309 closed<span class="toot-id"> #closed-1309</span></h2><div class="pubdate">23 Jul at 16:08:55 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1309">https://github.com/qt4cg/qtspecs/issues/1309</a></div><p>Dangling else syntax ambiguity</p></div>
<div class="toot" id="closed-1327"><h2>Issue #1327 closed<span class="toot-id"> #closed-1327</span></h2><div class="pubdate">23 Jul at 16:08:54 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1327">https://github.com/qt4cg/qtspecs/pull/1327</a></div><p>1309 bare brace ambiguities</p></div>
<div class="toot" id="closed-1331"><h2>Issue #1331 closed<span class="toot-id"> #closed-1331</span></h2><div class="pubdate">23 Jul at 16:05:40 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1331">https://github.com/qt4cg/qtspecs/pull/1331</a></div><p>1324 Introduce markup for executable specs</p></div>
<div class="toot" id="closed-1317"><h2>Issue #1317 closed<span class="toot-id"> #closed-1317</span></h2><div class="pubdate">23 Jul at 16:00:06 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1317">https://github.com/qt4cg/qtspecs/issues/1317</a></div><p>Record Test Subtype Relationship</p></div>
<div class="toot" id="closed-1332"><h2>Issue #1332 closed<span class="toot-id"> #closed-1332</span></h2><div class="pubdate">23 Jul at 16:00:05 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1332">https://github.com/qt4cg/qtspecs/pull/1332</a></div><p>1317 Fix the record subtyping rules</p></div>
<div class="toot" id="closed-1263"><h2>Issue #1263 closed<span class="toot-id"> #closed-1263</span></h2><div class="pubdate">23 Jul at 15:59:00 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1263">https://github.com/qt4cg/qtspecs/pull/1263</a></div><p>1224 Add xsl:accumulator-rule/@priority attribute</p></div>
<div class="toot" id="closed-1326"><h2>Issue #1326 closed<span class="toot-id"> #closed-1326</span></h2><div class="pubdate">23 Jul at 15:58:22 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1326">https://github.com/qt4cg/qtspecs/issues/1326</a></div><p>Misleading summary for concat() - "string value"</p></div>
<div class="toot" id="closed-1328"><h2>Issue #1328 closed<span class="toot-id"> #closed-1328</span></h2><div class="pubdate">23 Jul at 15:58:21 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1328">https://github.com/qt4cg/qtspecs/pull/1328</a></div><p>1326 wording improvements for concat and string-join</p></div>
<div class="toot" id="created-1342"><h2>Pull request #1342 created<span class="toot-id"> #created-1342</span></h2><div class="pubdate">23 Jul at 13:56:56 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1342">https://github.com/qt4cg/qtspecs/pull/1342</a></div><details><summary>1339 Deprecate ordering mode declaration</summary><div class="markup"><p>The "declare ordering mode" declaration, and the <code>ordered{}</code> and <code>unordered{}</code> declarations are retained for compatibility, but are deprecated and no longer have any effect.</p>
<p>Fix #1339</p>
</div></details></div>
<div class="toot" id="created-1341"><h2>Issue #1341 created<span class="toot-id"> #created-1341</span></h2><div class="pubdate">22 Jul at 21:11:13 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1341">https://github.com/qt4cg/qtspecs/issues/1341</a></div><details><summary>Remove the `$position`  argument from the `$action` function passed to folds</summary><div class="markup"><p><strong>The <code>$position</code>  argument, passed to the <code>$action</code>-function-argument of the folds is unnecessary and artificial</strong>:</p>
<ol>
<li>The addition of this argument resulted from the <strong><em>automatic</em></strong>  adding this position-aware <code>$action</code>-function-argument to all functions processing sequences and producing result based on their values.</li>
<li>In doing so, no further analysis was made on the specifics of the fold functions.</li>
<li>Though this issue has been raised again and again for months, no single and meaningful use-case has been provided.</li>
<li>This addition departs away from the original meaning of folds as has been well-established by the developers community. Whether or not one needs to produce a variety of folds, such as <em>sum, min, max, average, product, all / none / some / any</em> - in all these cases the position of the individual items does not matter.</li>
<li>One bad consequence of this change is that it makes it more difficult for the reader to grasp the meaning of a particular fold-function, and even to wonder if the spec talks about the same fold functions that the reader thought he knew well.</li>
<li>This change results in unnecessarily complex documentation and testing.</li>
<li>Users have expressed their dismay over the resulting complexity. To quote @benibela: <a href="https://github.com/qt4cg/qtspecs/pull/1296#issuecomment-2226997813">"<em>Too many variables make the code hard too read. And the implementation becomes slow, when it has to handle too many arguments. Especially with function coercion adding further type checks</em>" </a>.
And @michaelhkay himself: "<em><a href="https://github.com/qt4cg/qtspecs/pull/1296#issuecomment-2186435979">I'm inclined to propose dropping the position argument for both fold and scan. It complicates the specification and the use cases are unconvincing. I believe it has been incorrectly specified (for fold-left, the first time $action is called, the value supplied for $pos is 2, whereas for fold-right it is count($input)-1; and the "Error conditions" section talks of $action being applied to 2 arguments). For the -right forms in particular, the semantics are mind-bending enough without introducing this complication.</a></em>"</li>
<li>It is very easy to make an accidental mistake and pass a 2-arg. <code>$action</code> function when a 3-arg. function was meant (or the other way around).</li>
<li>The giant think-tank of Microsoft gives us a good example of a better solution. They never added position-aware overloads to any folds or fold related methods of the Enumerable class. All the following methods do not have position-aware action-function arguments:</li>
</ol>
<ul>
<li>
<p><strong><em><a href="url">Aggregate</a></em></strong></p>
</li>
<li>
<p><strong><em><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.all?view=net-8.0">All</a></em></strong></p>
</li>
<li>
<p><strong><em><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.any?view=net-8.0">Any</a></em></strong></p>
</li>
<li>
<p><strong><em><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.average?view=net-8.0">Average</a></em></strong></p>
</li>
<li>
<p><strong><em><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.first?view=net-8.0">First</a></em></strong></p>
</li>
<li>
<p><strong><em><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.firstordefault?view=net-8.0">FirstOrDefault</a></em></strong></p>
</li>
<li>
<p><strong><em><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.last?view=net-8.0">Last</a></em></strong></p>
</li>
<li>
<p><strong><em><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.lastordefault?view=net-8.0">LastOrDefault</a></em></strong></p>
</li>
<li>
<p><strong><em><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.max?view=net-8.0">Max</a></em></strong></p>
</li>
<li>
<p><strong><em><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.maxby?view=net-8.0">MaxBy</a></em></strong></p>
</li>
<li>
<p><strong><em><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.min?view=net-8.0">Min</a></em></strong></p>
</li>
<li>
<p><strong><em><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.minby?view=net-8.0">MinBy</a></em></strong></p>
</li>
<li>
<p><strong><em><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.zip?view=net-8.0">Zip</a></em></strong></p>
<p>This is not an accidental mistake, as Microsoft added to other Enumerable methods overloads that do require position-aware <code>$action</code>-function arguments:</p>
</li>
<li>
<p><strong><em><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.select?view=net-8.0#system-linq-enumerable-select-2(system-collections-generic-ienumerable((-0))-system-func((-0-system-int32-1)))">Select</a></em></strong></p>
</li>
<li>
<p><strong><em><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.selectmany?view=net-8.0">SelectMany</a></em></strong></p>
</li>
<li>
<p><strong><em><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.skipwhile?view=net-8.0">SkipWhile</a></em></strong></p>
</li>
<li>
<p><strong><em><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.takewhile?view=net-8.0">TakeWhile</a></em></strong></p>
</li>
<li>
<p><strong><em><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.where?view=net-8.0#system-linq-enumerable-where-1(system-collections-generic-ienumerable((-0))-system-func((-0-system-int32-system-boolean)))">Where</a></em></strong></p>
</li>
</ul>
<ol start="10">
<li>Last and probably most important: <a href="https://github.com/qt4cg/qtspecs/pull/1296#issuecomment-2194049829"><strong>@michaelhkay gave us a general and an elegant and very readable way</strong></a> of expressing any fold that needs positional information as a 2-step operation where the 1st step creates a map with entries: <code>{"position": $input[$pos]}</code> and then a fold-operation that only has a non-position-aware <code>$action</code>-function argument, and has this map as input.</li>
</ol>
<p><strong>Proposed solution</strong>:</p>
<ol>
<li>Leave the folds unchanged - in order to preserve their original, established meaning and avoid introducing inadequate complexity.</li>
<li>If deemed really necessary, define separate functions that can take as parameter a position-aware <code>$action</code>-function.</li>
</ol>
</div></details></div>
<div class="toot" id="created-1340"><h2>Issue #1340 created<span class="toot-id"> #created-1340</span></h2><div class="pubdate">22 Jul at 12:04:52 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1340">https://github.com/qt4cg/qtspecs/issues/1340</a></div><details><summary>Namespace nodes and the namespace axis</summary><div class="markup"><p>It would be nice to bring XSLT, XPath, and XQuery into line here.</p>
<p>The current state of play seems to be:</p>
<p>XQuery: the namespace axis is not supported. Namespace nodes can be constructed, but they exist only as detached orphans; they can never be attached to a parent element.</p>
<p>XPath: the namespace axis is deprecated and support is optional. There is no mechanism for constructing namespace nodes.</p>
<p>XSLT: the namespace axis is mandatory. Namespace nodes can be constructed and can be attached to elements.</p>
<p>I believe that the only reason for the differences is that XQuery implementors were concerned that it would be difficult to implement namespace nodes efficiently. I think XSLT has clearly demonstrated that this concern is unjustified.</p>
<p>However, there are implementation complexities, primarily around the fact that namespace nodes have identity and parentage, so if a namespace is declared on a root element, then every element in the document has a namespace node for this namespace, and these have distinct identity. To implement this efficiently, the implementation has to instantiate namespace nodes lazily on demand, and then has to ensure that if the "same" namespace node is instantiated again, it has the same "identity".</p>
<p>I suggest a solution along the following lines, applied to all three languages:</p>
<p>(a) the namespace axis is supported and delivers namespace nodes</p>
<p>(b) operations that depend on the ordering, identity, or parentage of namespace nodes are deprecated and implementation-defined.</p>
<p>(c) the data model says that the in-scope namespaces of an element are in the form of a (prefix, URI) map. The semantics of the namespace axis are described in terms of constructing transient namespace nodes from this map.</p>
</div></details></div>
<div class="toot" id="created-1339"><h2>Issue #1339 created<span class="toot-id"> #created-1339</span></h2><div class="pubdate">22 Jul at 11:40:07 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1339">https://github.com/qt4cg/qtspecs/issues/1339</a></div><details><summary>Drop unordered mode</summary><div class="markup"><p>Is there any evidence that unordered mode is useful, or that any implementations actually take note of it (by delivering a different result if unordered mode is set)?</p>
<p>If not, could we drop it? I would suggest continuing to recognize the syntax, marking it deprecated, and saying it has no effect.</p>
<p>It's not doing a great deal of harm, but there are a lot of places where our examples in the spec assume ordered mode, but the examples don't explicitly call out this assumption. Similarly, a great many QT3 test cases would fail on an implementation that sets unordered mode by default.</p>
</div></details></div>
<div class="toot" id="created-1338"><h2>Issue #1338 created<span class="toot-id"> #created-1338</span></h2><div class="pubdate">22 Jul at 11:05:42 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1338">https://github.com/qt4cg/qtspecs/issues/1338</a></div><details><summary>Arrays and maps: Members, entries, values, contents, pairs, …</summary><div class="markup"><p>With version 4.0, we are adding a lot of promising and powerful new map and array features. This is a big step forward, compared to the obvious limitations of 3.1.</p>
<p>Some aspects of the 3.1 design have made it difficult (or impossible) to fully adjust array and maps, but (in my opinion) the old overall concept was impressively consistent – and it is definitely a big challenge to achieve a 4.0 design that is not too fragmented.</p>
<p>To me, this becomes particularly evident in the case of arrays. The following example sums up the items of all members of an array. For the cumbersome 3.1 solution…</p>
<pre><code class="language-xquery">for $pos in 1 to array:size($array)
return sum($array($pos))
</code></pre>
<p>…we now have at least several (roughly?) equivalent options to do this; for example…</p>
<ol>
<li><code>for member $m in $array return sum($m)</code></li>
<li><code>array:members($array) ! sum(?value)</code></li>
<li><code>$array?entry::* ! sum(?value)</code></li>
<li><code>$array?value::* ! sum(.)</code></li>
</ol>
<p>…which is great – but the downside is that we have introduced a terminological jungle. The examples above could imply that:</p>
<ul>
<li>for 1., an <em>array member</em> is a sequence (which it indeed is);</li>
<li>for 2., an <em>array member</em> is a map;</li>
<li>for 3., an <em>array</em> has entries (but there is no <code>array:entries</code>);</li>
<li>for 4., an <em>array</em> has values (which is true, but <code>array:value</code> returns a different structure).</li>
</ul>
<p>Next, with the current proposals, <code>$array:content::1</code> gives us the sequence-concatenated version of the first member of an array. Similar observations can be made with maps: <code>map:entries($map)</code> returns singleton maps, whereas <code>$map?entry::*</code> is actually equivalent to <code>map:pairs</code>.</p>
<p>The fundamental obstacle are clear have already been discussed a lot, but I think that with each new concept, we should try really hard not to blur terminology, and work with terms that users can assign to the underlying concepts without too much guessing or trial’n’error.</p>
<p>My general suggestions would be to…</p>
<ol>
<li>align the new lookup terminology and the builtin functions, and</li>
<li>omit, rename or drop builtin functions that do not rely on the existing or arising terminology.</li>
</ol>
<p>My concrete proposals (maybe followed by others) would be to…</p>
<ol>
<li>As we already have <code>map:pairs</code>, <code>$map-or-array?entry::*</code> should become <code>$map-or-array?pair::*</code>, and we should add a <code>array:pairs</code> function, and probably <code>array:of-pairs</code> (see #832). We shouldn’t do it the other way round and rename <code>map:pairs</code> to <code>map:entries</code>, as the existing <code>map:entry</code> function returns a singleton map.</li>
<li>If we keep calling the sequence-concatenated result “content”, we should include it in the definition of sequence-concatenation. In addition, <code>(array|map):values</code> should be renamed to <code>(array|map):contents</code> (see #1179).</li>
<li>Due to the existence of <code>array:value::*</code>, we should make clear what an “array value” is, how it it positions itself in relation to an “array member”, and we should add <code>map:values</code> and <code>array:values</code> for equivalent results.</li>
<li>Due to the existence of <code>array:key::*</code>, we should add a <code>array:keys</code> function (which returns a dense integer range). <code>1&nbsp;to&nbsp;array:size($array)</code> could then be written as <code>array:keys($array)</code>.</li>
<li>As we have <code>map:entries</code> and <code>map:merge</code>, we could add equivalent <code>array:entries</code> and <code>array:merge</code> functions.</li>
<li>I would suggesting dropping <code>array:members</code>/<code>array:of-members</code> in favor of either <code>array:split</code>/<code>array:join</code>, <code>array:pairs</code>/<code>array:of-pairs</code> (see 1.) or <code>array:entries</code>/<code>array:merge</code> (see 5). I have a strong conviction that an “array member“ should not be a map; an “array pair” or ”array entry” certainly could.</li>
</ol>
<p>One might question if we should really introduce map terminology for arrays. I think we have no other chance if we want to treat maps and arrays identically with lookup key specifiers, and it may help us later on to treat both data structures as similar as possible.</p>
</div></details></div>
<div class="toot" id="created-1337"><h2>Issue #1337 created<span class="toot-id"> #created-1337</span></h2><div class="pubdate">22 Jul at 08:55:16 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1337">https://github.com/qt4cg/qtspecs/issues/1337</a></div><details><summary>Atomic value → atomic item</summary><div class="markup"><p>I liked @michaelhkay’s proposal in https://github.com/qt4cg/qtspecs/issues/826#issuecomment-1821359131:</p>
<blockquote>
<p>• The term "atomic item" (or just atom?) replaces "atomic value".</p>
</blockquote>
<p>I often used “atomic items” in the past (although it’s no defined term at the moment) as it seemed more intuitive to me.</p>
</div></details></div>
<div class="toot" id="created-1336"><h2>Issue #1336 created<span class="toot-id"> #created-1336</span></h2><div class="pubdate">22 Jul at 08:10:34 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1336">https://github.com/qt4cg/qtspecs/issues/1336</a></div><details><summary>Editorial: fos record descriptions within xmlspec prose</summary><div class="markup"><p>In the F+O spec, the <code>uri-structure-record</code> appearing in section 6.6, and various other similar record descriptions, are defined using the <code>fos</code> namespace markup in xpath-functions.xml. Normally the <code>fos</code> XML vocabulary is confined to function-catalog.xml, and is converted to the usual xmlspec vocabulary by the <code>merge-function-specs</code> stylesheet.</p>
<p>Using this vocabulary directly within an xmlspec document means that the document doesn't validate against its DTD, and that the <code>fos</code> islands aren't validated against the fos.xsd schema.</p>
<p>A better approach here might be to use XInclude to insert text from a separate, schema-validated, document.</p>
</div></details></div>
<div class="toot" id="closed-31"><h2>Issue #31 closed<span class="toot-id"> #closed-31</span></h2><div class="pubdate">21 Jul at 21:48:10 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/31">https://github.com/qt4cg/qtspecs/issues/31</a></div><p>Extend FLWOR expressions to maps</p></div>
<div class="toot" id="closed-1160"><h2>Issue #1160 closed<span class="toot-id"> #closed-1160</span></h2><div class="pubdate">21 Jul at 21:31:34 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1160">https://github.com/qt4cg/qtspecs/issues/1160</a></div><p>fn:is-collation-available</p></div>
<div class="toot" id="closed-1334"><h2>Issue #1334 closed<span class="toot-id"> #closed-1334</span></h2><div class="pubdate">21 Jul at 21:22:56 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1334">https://github.com/qt4cg/qtspecs/issues/1334</a></div><p>map:build parameter keywords</p></div>
<div class="toot" id="created-1335"><h2>Issue #1335 created<span class="toot-id"> #created-1335</span></h2><div class="pubdate">20 Jul at 09:51:33 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1335">https://github.com/qt4cg/qtspecs/issues/1335</a></div><details><summary>Data Model primitives for Maps and Arrays</summary><div class="markup"><p>In principle we ought to be able to define all operations on maps and arrays in terms of the primitives defined in the Data Model spec.</p>
<p>Currently the data model defines the primitives as <code>dm:map-entries</code>, <code>dm:array-size</code>, and <code>dm:array-get</code>.</p>
<p>This is a workable set for retrieval functions, though it's not necessarily an ideal set. But what is missing is any primitives for map and array construction.</p>
<p>I think we need to regard the empty array and empty map as given, and then define array:append and map:put as primitives.</p>
<p>Since <code>dm:map-entries()</code> isn't the same as the user-visible <code>map:entries()</code> it might be a good idea to rename it.</p>
<p>Another way of defining the primitives would be to make iteration primitive, so the primitives become</p>
<p><code>dm:for-each-map-entry($map, fn($key, $value)) </code>
and</p>
<p><code>dm:for-each-array-member($array, fn($position, $value))</code></p>
<p>This has some merit in that (a) maps and arrays are treated symmetrically, and (b) there are only 2 primitives rather than 3.</p>
</div></details></div>
<div class="toot" id="created-1334"><h2>Issue #1334 created<span class="toot-id"> #created-1334</span></h2><div class="pubdate">20 Jul at 06:58:12 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1334">https://github.com/qt4cg/qtspecs/issues/1334</a></div><details><summary>map:build parameter keywords</summary><div class="markup"><p>Currently <code>$keys, $value</code>. Both should be plural.</p>
</div></details></div>
<div class="toot" id="created-1333"><h2>Pull request #1333 created<span class="toot-id"> #created-1333</span></h2><div class="pubdate">19 Jul at 16:43:49 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1333">https://github.com/qt4cg/qtspecs/pull/1333</a></div><details><summary>1329 Add content option to load-xquery-module</summary><div class="markup"><p>Fix #1329</p>
</div></details></div>
<div class="toot" id="created-1332"><h2>Pull request #1332 created<span class="toot-id"> #created-1332</span></h2><div class="pubdate">19 Jul at 16:11:30 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1332">https://github.com/qt4cg/qtspecs/pull/1332</a></div><details><summary>1317 Fix the record subtyping rules</summary><div class="markup"><p>Fix as proposed in the issue.</p>
<p>Fix #1317</p>
</div></details></div>
<div class="toot" id="created-1331"><h2>Pull request #1331 created<span class="toot-id"> #created-1331</span></h2><div class="pubdate">19 Jul at 15:42:18 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1331">https://github.com/qt4cg/qtspecs/pull/1331</a></div><details><summary>1324 Introduce markup for executable specs</summary><div class="markup"><p>This PR does the following:</p>
<ol>
<li>Makes schema changes for the function catalog to allow an executable specification of a function to be marked up as such.</li>
<li>Uses this markup initially for functions in the array namespace.</li>
<li>Makes stylesheet changes to render this markup in the published spec.</li>
<li>Commits an XSLT stylesheet (not yet integrated into the build system) that runs against the function catalog to produce an XQuery module whose effect is to declare functions based on the "executable specifications" and run the published executable examples against these functions, checking that they produce the expected result. The "success" output of this query (which runs with no source document) is an XML document containing an empty element <code>&lt;result/&gt;</code>. (If it has content, this will relate to tests that failed).</li>
</ol>
<p>To get this to work, I had to tweak a couple of functions (array:sort and array:get) where Saxon has not yet implemented the required functionality. Although the test query is using the implementations from the spec, not those from Saxon, these implementations make calls on other functions where the Saxon implementation is used. For example array:fold-left calls fn:fold-left and this currently uses the Saxon implementation of fn:fold-left.</p>
<p>The query binds a dummy namespace to the <code>array</code> prefix to avoid problems with reserved namespaces. There are a couple of "core" functions that have no executable specification -- notably array:of-members() -- and the generated query contains an implementation of these that maps the function in the dummy array namespace to the function in the true array namespace.</p>
<p>This is phase 1. Most of the machinery is in place. It now needs to be applied to executable specifications of functions in other namespaces.</p>
<p>The stylesheet has no Saxon dependencies, but it does include a couple of template rules to exclude specific functions/tests that Saxon does not currently implement. The stylesheet could be made portable across implementations by moving these exception cases to an overriding stylesheet module.</p>
<p>I did find a few examples of supposedly executable code that needed fixing; hopefully these will show up in the diff version.</p>
</div></details></div>
<div class="toot" id="created-1330"><h2>Issue #1330 created<span class="toot-id"> #created-1330</span></h2><div class="pubdate">19 Jul at 14:26:46 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1330">https://github.com/qt4cg/qtspecs/issues/1330</a></div><details><summary>$fallback argument of map:get() and array:get() should allow () to be supplied</summary><div class="markup"><p>As a general rule, if an argument is optional then it should accept an empty sequence.</p>
</div></details></div>
<div class="toot" id="created-1329"><h2>Issue #1329 created<span class="toot-id"> #created-1329</span></h2><div class="pubdate">19 Jul at 07:29:04 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1329">https://github.com/qt4cg/qtspecs/issues/1329</a></div><details><summary>load-xquery-module supplying content</summary><div class="markup"><p>I propose to provide an additional option</p>
<p><code>content as xs:string</code></p>
<p>for fn:load-xquery-module. The effect is to supply the content of the XQuery library module as a string. If supplied, the location-hints option is ignored.</p>
<p>Use case: I'm writing code that attempts to test the XQuery examples in the specification. This requires some kind of capability for dynamic XQuery execution, and this seems the simplest way of doing it.</p>
</div></details></div>
<div class="toot" id="created-1328"><h2>Pull request #1328 created<span class="toot-id"> #created-1328</span></h2><div class="pubdate">18 Jul at 22:11:38 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1328">https://github.com/qt4cg/qtspecs/pull/1328</a></div><details><summary>1326 wording improvements for concat and string-join</summary><div class="markup"><p>Very minor editorial improvements.</p>
<p>Fix #1326</p>
</div></details></div>
<div class="toot" id="created-1327"><h2>Pull request #1327 created<span class="toot-id"> #created-1327</span></h2><div class="pubdate">18 Jul at 20:56:50 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1327">https://github.com/qt4cg/qtspecs/pull/1327</a></div><details><summary>1309 bare brace ambiguities</summary><div class="markup"><p>Fix #1309</p>
<p>The proposal restructures the grammar so a bare brace map constructor (that is, one without the "map" keyword) can be used only where this causes no ambiguity, for example as a function argument.</p>
</div></details></div>
<div class="toot" id="created-1326"><h2>Issue #1326 created<span class="toot-id"> #created-1326</span></h2><div class="pubdate">17 Jul at 15:57:40 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1326">https://github.com/qt4cg/qtspecs/issues/1326</a></div><details><summary>Misleading summary for concat() - "string value"</summary><div class="markup"><p>The summary of fn:concat says that it concatenates the string values of its arguments. This isn't strictly correct: if a node is supplied as an argument, the node is atomized and the typed value is cast to a string, which doesn't necessarily give you the same result. For example (a) if the node is an attribute whose type is list, the result is the elements of the list without space separation, and (b) if the node is an element with element-only content, concat() fails although string() would succeed.</p>
<p>In 3.1, supplying a list-valued attribute would fail because the required type of each argument was <code>xs:anyAtomicType?</code>. It now succeeds because the required type is <code>xs:anyAtomicType?</code> - but perhaps it doesn't have the desired effect?</p>
<p>We should clarify these points with notes and examples. Also affects the <code>||</code> operator.</p>
</div></details></div></div><p>See 2658
            more statuses in yearly archives.</p></article></main></body></html>