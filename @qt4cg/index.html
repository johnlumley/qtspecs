<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><link rel="stylesheet" href="/css/status.css"><title>@qt4cg statuses</title></head><body><main><article><h1>@qt4cg statuses</h1><p>This page displays recent status
            updates
            about the QT4CG project.</p><p>The are also captured in <a href="status.rss">an RSS feed</a>.</p><p>By year: <a href="2024/">2024</a>, <a href="2023/">2023</a>, <a href="2022/">2022</a>, <a href="2021/">2021</a>, <a href="2020/">2020</a></p><div class="toots">
<div class="toot" id="created-1338"><h2>Issue #1338 created<span class="toot-id"> #created-1338</span></h2><div class="pubdate">22 Jul at 11:05:42 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1338">https://github.com/qt4cg/qtspecs/issues/1338</a></div><details><summary>Arrays and maps: Members, entries, values, contents, pairs, …</summary><div class="markup"><p>With version 4.0, we are adding a lot of promising and powerful new map and array features. This is a big step forward, compared to the obvious limitations of 3.1.</p>
<p>Some aspects of the 3.1 design have made it difficult (or impossible) to fully adjust array and maps, but (in my opinion) the old overall concept was impressively consistent – and it is definitely a big challenge to achieve a 4.0 design that is not too fragmented.</p>
<p>To me, this becomes particularly evident in the case of arrays. The following example sums up the items of all members of an array. For the cumbersome 3.1 solution…</p>
<pre><code class="language-xquery">for $pos in 1 to array:size($array)
return sum($array($pos))
</code></pre>
<p>…we now have at least several (roughly?) equivalent options to do this; for example…</p>
<ol>
<li><code>for member $m in $array return sum($m)</code></li>
<li><code>array:members($array) ! sum(?value)</code></li>
<li><code>$array?entry::* ! sum(?value)</code></li>
<li><code>$array?value::* ! sum(.)</code></li>
</ol>
<p>…which is great – but the downside is that we have introduced a terminological jungle. The examples above could imply that:</p>
<ul>
<li>for 1., an <em>array member</em> is a sequence (which it indeed is);</li>
<li>for 2., an <em>array member</em> is a map;</li>
<li>for 3., an <em>array</em> has entries (but there is no <code>array:entries</code>);</li>
<li>for 4., an <em>array</em> has values (which is true, but <code>array:value</code> returns a different structure).</li>
</ul>
<p>Next, with the current proposals, <code>$array:content::1</code> gives us the sequence-concatenated version of the first member of an array. Similar observations can be made with maps: <code>map:entries($map)</code> returns singleton maps, whereas <code>$map?entry::*</code> is actually equivalent to <code>map:pairs</code>.</p>
<p>The fundamental obstacle are clear have already been discussed a lot, but I think that with each new concept, we should try really hard not to blur terminology, and work with terms that users can assign to the underlying concepts without too much guessing or trial’n’error.</p>
<p>My general suggestions would be to…</p>
<ol>
<li>align the new lookup terminology and the builtin functions, and</li>
<li>omit, rename or drop builtin functions that do not rely on the existing or arising terminology.</li>
</ol>
<p>My concrete proposals (maybe followed by others) would be to…</p>
<ol>
<li>As we already have <code>map:pairs</code>, <code>$map-or-array?entry::*</code> should become <code>$map-or-array?pair::*</code>, and we should add a <code>array:pairs</code> function, and probably <code>array:of-pairs</code> (see #832). We shouldn’t do it the other way round and rename <code>map:pairs</code> to <code>map:entries</code>, as the existing <code>map:entry</code> function returns a singleton map.</li>
<li>If we keep calling the sequence-concatenated result “content”, we should include it in the definition of sequence-concatenation. In addition, <code>(array|map):values</code> should be renamed to <code>(array|map):contents</code> (see #1179).</li>
<li>Due to the existence of <code>array:value::*</code>, we should make clear what an “array value” is, how it it positions itself in relation to an “array member”, and we should add <code>map:values</code> and <code>array:values</code> for equivalent results.</li>
<li>Due to the existence of <code>array:key::*</code>, we should add a <code>array:keys</code> function (which returns a dense integer range). <code>1&nbsp;to&nbsp;array:size($array)</code> could then be written as <code>array:keys($array)</code>.</li>
<li>As we have <code>map:entries</code> and <code>map:merge</code>, we could add equivalent <code>array:entries</code> and <code>array:merge</code> functions.</li>
<li>I would suggesting dropping <code>array:members</code>/<code>array:of-members</code> in favor of either <code>array:split</code>/<code>array:join</code>, <code>array:pairs</code>/<code>array:of-pairs</code> (see 1.) or <code>array:entries</code>/<code>array:merge</code> (see 5). I have a strong conviction that an “array member“ should not be a map; an “array pair” or ”array entry” certainly could.</li>
</ol>
<p>One might question if we should really introduce map terminology for arrays. I think we have no other chance if we want to treat maps and arrays identically with lookup key specifiers, and it may help us later on to treat both data structures as similar as possible.</p>
</div></details></div>
<div class="toot" id="created-1337"><h2>Issue #1337 created<span class="toot-id"> #created-1337</span></h2><div class="pubdate">22 Jul at 08:55:16 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1337">https://github.com/qt4cg/qtspecs/issues/1337</a></div><details><summary>Atomic value → atomic item</summary><div class="markup"><p>I liked @michaelhkay’s proposal in https://github.com/qt4cg/qtspecs/issues/826#issuecomment-1821359131:</p>
<blockquote>
<p>• The term "atomic item" (or just atom?) replaces "atomic value".</p>
</blockquote>
<p>I often used “atomic items” in the past (although it’s no defined term at the moment) as it seemed more intuitive to me.</p>
</div></details></div>
<div class="toot" id="created-1336"><h2>Issue #1336 created<span class="toot-id"> #created-1336</span></h2><div class="pubdate">22 Jul at 08:10:34 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1336">https://github.com/qt4cg/qtspecs/issues/1336</a></div><details><summary>Editorial: fos record descriptions within xmlspec prose</summary><div class="markup"><p>In the F+O spec, the <code>uri-structure-record</code> appearing in section 6.6, and various other similar record descriptions, are defined using the <code>fos</code> namespace markup in xpath-functions.xml. Normally the <code>fos</code> XML vocabulary is confined to function-catalog.xml, and is converted to the usual xmlspec vocabulary by the <code>merge-function-specs</code> stylesheet.</p>
<p>Using this vocabulary directly within an xmlspec document means that the document doesn't validate against its DTD, and that the <code>fos</code> islands aren't validated against the fos.xsd schema.</p>
<p>A better approach here might be to use XInclude to insert text from a separate, schema-validated, document.</p>
</div></details></div>
<div class="toot" id="closed-31"><h2>Issue #31 closed<span class="toot-id"> #closed-31</span></h2><div class="pubdate">21 Jul at 21:48:10 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/31">https://github.com/qt4cg/qtspecs/issues/31</a></div><p>Extend FLWOR expressions to maps</p></div>
<div class="toot" id="closed-1160"><h2>Issue #1160 closed<span class="toot-id"> #closed-1160</span></h2><div class="pubdate">21 Jul at 21:31:34 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1160">https://github.com/qt4cg/qtspecs/issues/1160</a></div><p>fn:is-collation-available</p></div>
<div class="toot" id="closed-1334"><h2>Issue #1334 closed<span class="toot-id"> #closed-1334</span></h2><div class="pubdate">21 Jul at 21:22:56 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1334">https://github.com/qt4cg/qtspecs/issues/1334</a></div><p>map:build parameter keywords</p></div>
<div class="toot" id="created-1335"><h2>Issue #1335 created<span class="toot-id"> #created-1335</span></h2><div class="pubdate">20 Jul at 09:51:33 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1335">https://github.com/qt4cg/qtspecs/issues/1335</a></div><details><summary>Data Model primitives for Maps and Arrays</summary><div class="markup"><p>In principle we ought to be able to define all operations on maps and arrays in terms of the primitives defined in the Data Model spec.</p>
<p>Currently the data model defines the primitives as <code>dm:map-entries</code>, <code>dm:array-size</code>, and <code>dm:array-get</code>.</p>
<p>This is a workable set for retrieval functions, though it's not necessarily an ideal set. But what is missing is any primitives for map and array construction.</p>
<p>I think we need to regard the empty array and empty map as given, and then define array:append and map:put as primitives.</p>
<p>Since <code>dm:map-entries()</code> isn't the same as the user-visible <code>map:entries()</code> it might be a good idea to rename it.</p>
<p>Another way of defining the primitives would be to make iteration primitive, so the primitives become</p>
<p><code>dm:for-each-map-entry($map, fn($key, $value)) </code>
and</p>
<p><code>dm:for-each-array-member($array, fn($position, $value))</code></p>
<p>This has some merit in that (a) maps and arrays are treated symmetrically, and (b) there are only 2 primitives rather than 3.</p>
</div></details></div>
<div class="toot" id="created-1334"><h2>Issue #1334 created<span class="toot-id"> #created-1334</span></h2><div class="pubdate">20 Jul at 06:58:12 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1334">https://github.com/qt4cg/qtspecs/issues/1334</a></div><details><summary>map:build parameter keywords</summary><div class="markup"><p>Currently <code>$keys, $value</code>. Both should be plural.</p>
</div></details></div>
<div class="toot" id="created-1333"><h2>Pull request #1333 created<span class="toot-id"> #created-1333</span></h2><div class="pubdate">19 Jul at 16:43:49 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1333">https://github.com/qt4cg/qtspecs/pull/1333</a></div><details><summary>1329 Add content option to load-xquery-module</summary><div class="markup"><p>Fix #1329</p>
</div></details></div>
<div class="toot" id="created-1332"><h2>Pull request #1332 created<span class="toot-id"> #created-1332</span></h2><div class="pubdate">19 Jul at 16:11:30 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1332">https://github.com/qt4cg/qtspecs/pull/1332</a></div><details><summary>1317 Fix the record subtyping rules</summary><div class="markup"><p>Fix as proposed in the issue.</p>
<p>Fix #1317</p>
</div></details></div>
<div class="toot" id="created-1331"><h2>Pull request #1331 created<span class="toot-id"> #created-1331</span></h2><div class="pubdate">19 Jul at 15:42:18 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1331">https://github.com/qt4cg/qtspecs/pull/1331</a></div><details><summary>1324 Introduce markup for executable specs</summary><div class="markup"><p>This PR does the following:</p>
<ol>
<li>Makes schema changes for the function catalog to allow an executable specification of a function to be marked up as such.</li>
<li>Uses this markup initially for functions in the array namespace.</li>
<li>Makes stylesheet changes to render this markup in the published spec.</li>
<li>Commits an XSLT stylesheet (not yet integrated into the build system) that runs against the function catalog to produce an XQuery module whose effect is to declare functions based on the "executable specifications" and run the published executable examples against these functions, checking that they produce the expected result. The "success" output of this query (which runs with no source document) is an XML document containing an empty element <code>&lt;result/&gt;</code>. (If it has content, this will relate to tests that failed).</li>
</ol>
<p>To get this to work, I had to tweak a couple of functions (array:sort and array:get) where Saxon has not yet implemented the required functionality. Although the test query is using the implementations from the spec, not those from Saxon, these implementations make calls on other functions where the Saxon implementation is used. For example array:fold-left calls fn:fold-left and this currently uses the Saxon implementation of fn:fold-left.</p>
<p>The query binds a dummy namespace to the <code>array</code> prefix to avoid problems with reserved namespaces. There are a couple of "core" functions that have no executable specification -- notably array:of-members() -- and the generated query contains an implementation of these that maps the function in the dummy array namespace to the function in the true array namespace.</p>
<p>This is phase 1. Most of the machinery is in place. It now needs to be applied to executable specifications of functions in other namespaces.</p>
<p>The stylesheet has no Saxon dependencies, but it does include a couple of template rules to exclude specific functions/tests that Saxon does not currently implement. The stylesheet could be made portable across implementations by moving these exception cases to an overriding stylesheet module.</p>
<p>I did find a few examples of supposedly executable code that needed fixing; hopefully these will show up in the diff version.</p>
</div></details></div>
<div class="toot" id="created-1330"><h2>Issue #1330 created<span class="toot-id"> #created-1330</span></h2><div class="pubdate">19 Jul at 14:26:46 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1330">https://github.com/qt4cg/qtspecs/issues/1330</a></div><details><summary>$fallback argument of map:get() and array:get() should allow () to be supplied</summary><div class="markup"><p>As a general rule, if an argument is optional then it should accept an empty sequence.</p>
</div></details></div>
<div class="toot" id="created-1329"><h2>Issue #1329 created<span class="toot-id"> #created-1329</span></h2><div class="pubdate">19 Jul at 07:29:04 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1329">https://github.com/qt4cg/qtspecs/issues/1329</a></div><details><summary>load-xquery-module supplying content</summary><div class="markup"><p>I propose to provide an additional option</p>
<p><code>content as xs:string</code></p>
<p>for fn:load-xquery-module. The effect is to supply the content of the XQuery library module as a string. If supplied, the location-hints option is ignored.</p>
<p>Use case: I'm writing code that attempts to test the XQuery examples in the specification. This requires some kind of capability for dynamic XQuery execution, and this seems the simplest way of doing it.</p>
</div></details></div>
<div class="toot" id="created-1328"><h2>Pull request #1328 created<span class="toot-id"> #created-1328</span></h2><div class="pubdate">18 Jul at 22:11:38 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1328">https://github.com/qt4cg/qtspecs/pull/1328</a></div><details><summary>1326 wording improvements for concat and string-join</summary><div class="markup"><p>Very minor editorial improvements.</p>
<p>Fix #1326</p>
</div></details></div>
<div class="toot" id="created-1327"><h2>Pull request #1327 created<span class="toot-id"> #created-1327</span></h2><div class="pubdate">18 Jul at 20:56:50 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1327">https://github.com/qt4cg/qtspecs/pull/1327</a></div><details><summary>1309 bare brace ambiguities</summary><div class="markup"><p>Fix #1309</p>
<p>The proposal restructures the grammar so a bare brace map constructor (that is, one without the "map" keyword) can be used only where this causes no ambiguity, for example as a function argument.</p>
</div></details></div>
<div class="toot" id="created-1326"><h2>Issue #1326 created<span class="toot-id"> #created-1326</span></h2><div class="pubdate">17 Jul at 15:57:40 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1326">https://github.com/qt4cg/qtspecs/issues/1326</a></div><details><summary>Misleading summary for concat() - "string value"</summary><div class="markup"><p>The summary of fn:concat says that it concatenates the string values of its arguments. This isn't strictly correct: if a node is supplied as an argument, the node is atomized and the typed value is cast to a string, which doesn't necessarily give you the same result. For example (a) if the node is an attribute whose type is list, the result is the elements of the list without space separation, and (b) if the node is an element with element-only content, concat() fails although string() would succeed.</p>
<p>In 3.1, supplying a list-valued attribute would fail because the required type of each argument was <code>xs:anyAtomicType?</code>. It now succeeds because the required type is <code>xs:anyAtomicType?</code> - but perhaps it doesn't have the desired effect?</p>
<p>We should clarify these points with notes and examples. Also affects the <code>||</code> operator.</p>
</div></details></div>
<div class="toot" id="created-1325"><h2>Issue #1325 created<span class="toot-id"> #created-1325</span></h2><div class="pubdate">16 Jul at 18:50:35 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1325">https://github.com/qt4cg/qtspecs/issues/1325</a></div><details><summary>Variadic System Functions: Principles?</summary><div class="markup"><p>In the current spec, the following functions are variadic:</p>
<ul>
<li><code>fn:concat</code></li>
<li><code>fn:codepoints-to-string</code></li>
<li><code>fn:distinct-ordered-nodes</code></li>
</ul>
<p>The advantage of the variadic representation is that a user can omit additional parentheses; the drawback is that the function cannot be enhanced with parameters later on. In my point of view, <code>fn:distinct-ordered-nodes</code> might be a candidate for that in the future (on the other hand, it will only be used by a very small user group one or the other way).</p>
<p>Other candidates for variadicity could be (among others):</p>
<ul>
<li><code>fn:count</code></li>
<li><code>fn:exists</code>, <code>fn:empty</code></li>
<li><code>fn:head</code>, <code>fn:tail</code>, <code>fn:trunk</code>, <code>fn:foot</code></li>
<li><code>fn:one-or-more</code>, <code>fn:exactly-one</code>, <code>fn:zero-or-one</code></li>
<li><code>fn:innermost</code>, <code>fn:outermost</code>, <code>fn:unordered</code>, <code>fn:reverse</code></li>
<li><code>fn:boolean</code>, <code>fn:not</code></li>
<li><code>fn:identity</code></li>
<li><code>fn:data</code>, <code>fn:has-children</code> (the 0-arity case would need to be preserved due to its special semantics)</li>
</ul>
<p>Note that function calls like <code>fn:exactly-one(E1, E2)</code> can be reasonable in practice, as <code>E1</code> may return an empty sequence.</p>
<p>I wonder if we can define a principle which functions should be variadic?</p>
</div></details></div>
<div class="toot" id="minutes-07-16"><h2>QT4 CG meeting 086 draft minutes<span class="toot-id"> #minutes-07-16</span></h2><div class="pubdate">16 Jul at 17:15:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2024/07-16">https://qt4cg.org/meeting/minutes/2024/07-16</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="created-1324"><h2>Issue #1324 created<span class="toot-id"> #created-1324</span></h2><div class="pubdate">16 Jul at 16:10:44 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1324">https://github.com/qt4cg/qtspecs/issues/1324</a></div><details><summary>Executable specifications</summary><div class="markup"><p>For a number of functions we have provided executable specifications: that is, we have provided an XQuery function declaration that claims to be a conformant implementation of the function being specified.</p>
<p>We should add machinery to ensure that these reference implementations are correct: that is, that they compile, that they correctly run the examples in the spec, and that they can be used to run the tests for the relevant function in the test suite.</p>
<p>There are one or two cases where we have been doing this in an ad-hoc way by having additional test cases in the test suite that use the reference implementation (or a copy of it!) in place of the real function; but this is clumsy and the process should be automated.</p>
<p>It can be tied in with the mechanism that currently generates test cases from the examples in the spec.</p>
<p>We should probably handle several levels:</p>
<p>(a) There are cases where the reference implementation can be a simple XPath expression: for example the function <code>fn:local-name($x)</code> delivers <code>fn:local-name-from-QName(fn:node-name($x))</code>.</p>
<p>(b) In other cases a full XQuery function declaration is needed, especially where it makes use of a supporting helper function.</p>
<p>Ideally the reference implementation should use 3.1 syntax only (to make it easily testable on 3.1 implementations); but not if this sacrifices clarity, given that the primary audience is the human reader.</p>
</div></details></div>
<div class="toot" id="closed-1244"><h2>Issue #1244 closed<span class="toot-id"> #closed-1244</span></h2><div class="pubdate">16 Jul at 16:03:15 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1244">https://github.com/qt4cg/qtspecs/pull/1244</a></div><p>566-partial Rewrite parse-uri</p></div>
<div class="toot" id="closed-1272"><h2>Issue #1272 closed<span class="toot-id"> #closed-1272</span></h2><div class="pubdate">16 Jul at 16:02:55 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1272">https://github.com/qt4cg/qtspecs/issues/1272</a></div><p>Add xsl:value-of/@as attribute</p></div>
<div class="toot" id="created-1323"><h2>Issue #1323 created<span class="toot-id"> #created-1323</span></h2><div class="pubdate">16 Jul at 13:11:43 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1323">https://github.com/qt4cg/qtspecs/issues/1323</a></div><details><summary>Function parameters names: $uri vs. $href</summary><div class="markup"><p>I was asked about the difference between the function parameter names <code>$href</code> and <code>$uri</code>…</p>
<ul>
<li><code>fn:doc($href)</code> (“Retrieves a document using a URI supplied as an <code>xs:string</code>…”); <code>fn:unparsed-text($href)</code>; others</li>
<li><code>fn:collection($uri)</code>, <code>fn:uri-collection($uri)</code>; others</li>
</ul>
<p>…and I couldn’t give a convincing answer. At least in BaseX, both <code>fn:doc</code> and <code>fn:collection</code> can be used interchangeably to address single resources (but things change when the target contains multiple resources).</p>
<p>Would it be reasonable to rename <code>$href</code> to <code>$uri</code>, or are there reasons why we need to differ those two?</p>
<p>If we rename the parameter, <code>fn:resolve-uri</code> may be the only function using <code>$href</code> (maybe even here, <code>$uri</code> could work?).</p>
</div></details></div>
<div class="toot" id="created-1322"><h2>Issue #1322 created<span class="toot-id"> #created-1322</span></h2><div class="pubdate">16 Jul at 13:00:14 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1322">https://github.com/qt4cg/qtspecs/issues/1322</a></div><details><summary>fn:collation-available (editorial)</summary><div class="markup"><p>Minor observations:</p>
<ol>
<li>As the function input is a plain URI, I would propose to rename <code>$collation</code> to <code>$uri</code> (see <code>fn:collection</code> and other functions).</li>
<li>I believe we should make <code>fn:collation-available($uri, ())</code> and <code>fn:collation-available($uri)</code> equivalent. Could we change the default value of <code>$usage</code> to <code>()</code>?</li>
<li>It would be helpful to have (successul and failing) examples for the <code>$usage</code> argument added to the specification. Maybe things get easier once test cases exist.</li>
</ol>
</div></details></div>
<div class="toot" id="created-1321"><h2>Issue #1321 created<span class="toot-id"> #created-1321</span></h2><div class="pubdate">15 Jul at 23:56:24 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1321">https://github.com/qt4cg/qtspecs/issues/1321</a></div><details><summary>Leading lone slash</summary><div class="markup"><p>PR #1313 clarifies how tokenization of direct constructors works.</p>
<p>As a result we should rephrase the section on "leading lone slash" in A.1.2. This currently says (inter alia)</p>
<blockquote>
<p>the &lt; token could be either an operator or the start of a [DirectConstructor]</p>
</blockquote>
<p>But we now speak of <strong>terminals</strong> rather than <strong>tokens</strong>, and a DirectConstructor is a terminal, whereas the <code>&lt;</code> character that appears at the start of a DirectConstructor is not a terminal.</p>
<p>The revised formulation affects the interpretation of examples like <code>/ &lt; 5</code> (test cases PathExpr-5 and PathExpr-8) which I believe are now valid in XP40 and XQ40 (<code>&lt;</code> as a character can appear at the start of a RelativePathExpr, but <code>&lt;</code> as a token/terminal can't).</p>
<p>The rule currently talks of a "token that can appear at the start of a RelativePathExpr" without enumerating the tokens/terminals that can do so. It would be helpful to both implementors and users (and test authors) if we could enumerate them - I believe we can construct a list by conducting a suitable query against the grammar.</p>
</div></details></div>
<div class="toot" id="closed-1266"><h2>Issue #1266 closed<span class="toot-id"> #closed-1266</span></h2><div class="pubdate">15 Jul at 14:07:00 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1266">https://github.com/qt4cg/qtspecs/pull/1266</a></div><p>1158 Add array mapping operator</p></div>
<div class="toot" id="created-1320"><h2>Issue #1320 created<span class="toot-id"> #created-1320</span></h2><div class="pubdate">11 Jul at 11:30:13 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1320">https://github.com/qt4cg/qtspecs/issues/1320</a></div><details><summary>fn:parse-uri: Observations</summary><div class="markup"><p>@ndw I decided to only give feedback on the first test that fails; maybe it makes things easier. Next, I chose this repository (instead of <code>qt4tests</code>), as you are the better person to judge if bugs are to be fixed in the tests or the spec.</p>
<p>The test case <a href="https://github.com/qt4cg/qt4tests/blob/5b0750b035d336040b4944dba6225e50bd004839/fn/parse-uri.xml#L239-L253">fn-parse-uri-012</a> uses <code>fn:parse-uri("file:///c:/path/to/file")</code> and returns:</p>
<pre><code class="language-xquery">{
  "uri": "file:///c:/path/to/file",
  "scheme": "file",
  "hierarchical": true(),
  "path": "/c:/path/to/file",
  "filepath": "c:/path/to/file",
  "path-segments": ("", "c:", "path", "to", "file")
}
</code></pre>
<p>Following the current rules, I would have expected <code>filepath</code> to be <code>/c:/path/to/file</code>:</p>
<pre><code>If URI matches `^([a-zA-Z][A-Za-z0-9\+\-\.]*):(.*)$`:
• SCHEME: file
• STRING: ///c:/path/to/file

If the scheme is known to be file and the string matches "^/*(/[a-zA-Z][:|].*)$":
• STRING: /c:/path/to/file

If the scheme is file or the empty sequence, and filepath is the empty sequence, filepath is also the whole string:
• FILEPATH: /c:/path/to/file
</code></pre>
<p>Would you propose to revise the test or the specification?</p>
</div></details></div>
<div class="toot" id="minutes-07-09"><h2>QT4 CG meeting 085 draft minutes<span class="toot-id"> #minutes-07-09</span></h2><div class="pubdate">09 Jul at 17:15:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2024/07-09">https://qt4cg.org/meeting/minutes/2024/07-09</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="closed-1158"><h2>Issue #1158 closed<span class="toot-id"> #closed-1158</span></h2><div class="pubdate">09 Jul at 16:26:51 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1158">https://github.com/qt4cg/qtspecs/issues/1158</a></div><p>Simple mapping operator for arrays</p></div>
<div class="toot" id="created-1319"><h2>Issue #1319 created<span class="toot-id"> #created-1319</span></h2><div class="pubdate">09 Jul at 16:20:56 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1319">https://github.com/qt4cg/qtspecs/issues/1319</a></div><details><summary>Specification Documents: Editors and Contributors</summary><div class="markup"><p>I have noticed that the headers of the specification documents of previous versions of the languages contain more than one editor. In some EXPath documents, both editors and contributors are listed (with editors doing the majority of the work).</p>
<p>As various people have now been contributing to the new specifications and the documents for the last months and years already, would it make sense (and would it match with the current W3 conventions) to name more than one person in the header? In either case, it should certainly made clear that Michael Kay has contributed the very vast majority of the contents.</p>
</div></details></div>
<div class="toot" id="closed-1306"><h2>Issue #1306 closed<span class="toot-id"> #closed-1306</span></h2><div class="pubdate">09 Jul at 16:15:24 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1306">https://github.com/qt4cg/qtspecs/pull/1306</a></div><p>46 Add @as attribute to xsl:sequence</p></div></div><p>See 2644
            more statuses in yearly archives.</p></article></main></body></html>