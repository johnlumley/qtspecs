<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><link rel="stylesheet" href="/css/status.css"><title>@qt4cg statuses</title></head><body><main><article><h1>@qt4cg statuses</h1><p>This page displays recent status
            updates
            about the QT4CG project.</p><p>The are also captured in <a href="status.rss">an RSS feed</a>.</p><p>By year: <a href="2024/">2024</a>, <a href="2023/">2023</a>, <a href="2022/">2022</a>, <a href="2021/">2021</a>, <a href="2020/">2020</a></p><div class="toots">
<div class="toot" id="agenda-05-21"><h2>QT4 CG meeting 078 draft agenda<span class="toot-id"> #agenda-05-21</span></h2><div class="pubdate">20 May at 11:00:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2024/05-21">https://qt4cg.org/meeting/agenda/2024/05-21</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="closed-1221"><h2>Issue #1221 closed<span class="toot-id"> #closed-1221</span></h2><div class="pubdate">19 May at 20:07:59 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1221">https://github.com/qt4cg/qtspecs/issues/1221</a></div><p>new function - fn:tail-recurse a function to allow users to hand roll their recursion and guarentee tail recursion.</p></div>
<div class="toot" id="created-1228"><h2>Pull request #1228 created<span class="toot-id"> #created-1228</span></h2><div class="pubdate">19 May at 17:56:50 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1228">https://github.com/qt4cg/qtspecs/pull/1228</a></div><details><summary>Adding the BLAKE3 hashing algorithm to fn:hash</summary><div class="markup"><p>This is a resubmission of the original https://github.com/qt4cg/qtspecs/pull/1226.
No new changes, this is fixing a pure git-technical issue.</p>
<p>Now the PR is submitted from a dedicated feature-branch and does not depend on any other branch</p>
</div></details></div>
<div class="toot" id="created-1227"><h2>Pull request #1227 created<span class="toot-id"> #created-1227</span></h2><div class="pubdate">19 May at 17:47:33 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1227">https://github.com/qt4cg/qtspecs/pull/1227</a></div><details><summary>PR resubmission for fn ranks</summary><div class="markup"><p>This is a resubmission of the original <a href="https://github.com/qt4cg/qtspecs/pull/1027">PR 1027 for function fn:ranks</a>.
No new changes, this is fixing a pure git-technical issue.</p>
<p>Now the PR is submitted from a dedicated feature-branch and not from <em>master</em></p>
</div></details></div>
<div class="toot" id="closed-1226"><h2>Issue #1226 closed<span class="toot-id"> #closed-1226</span></h2><div class="pubdate">19 May at 17:05:12 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1226">https://github.com/qt4cg/qtspecs/pull/1226</a></div><p>Add the BLAKE3 hashing algorithm to fn:hash</p></div>
<div class="toot" id="closed-1027"><h2>Issue #1027 closed<span class="toot-id"> #closed-1027</span></h2><div class="pubdate">19 May at 17:02:36 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1027">https://github.com/qt4cg/qtspecs/pull/1027</a></div><p>150 fn:ranks</p></div>
<div class="toot" id="created-1226"><h2>Pull request #1226 created<span class="toot-id"> #created-1226</span></h2><div class="pubdate">18 May at 22:33:31 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1226">https://github.com/qt4cg/qtspecs/pull/1226</a></div><details><summary>Add the BLAKE3 hashing algorithm to fn:hash</summary><div class="markup"><p>This PR adds the <strong>BLAKE3</strong> hashing algorithm as one of the hashing algorithms in <strong><code>fn:hash</code></strong></p>
<p>This comes from a different branch than the one that contains the PR for <strong><code>fn:ranks</code></strong>, thus both PRs must be active and independent of each other.</p>
</div></details></div>
<div class="toot" id="created-1225"><h2>Issue #1225 created<span class="toot-id"> #created-1225</span></h2><div class="pubdate">18 May at 08:33:50 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1225">https://github.com/qt4cg/qtspecs/issues/1225</a></div><details><summary>Generalization of Deep Updates</summary><div class="markup"><p><strong>Note:</strong> This is a discussion issue, as I cannot contribute something substantial so far.</p>
<h3>Observations</h3>
<p>Our current development to support updates in the languages may come as a surprise to developers:</p>
<ul>
<li>The XQuery core specification (which includes <strong>X</strong> in its name) will include constructs for updating <strong>Maps</strong> and <strong>Arrays</strong>.</li>
<li>To update <strong>XML</strong>, an implementation must support the XQuery Update (XQUF) specification.</li>
</ul>
<p>I think we should…</p>
<ol>
<li>either embed map/array updates in XQUF, or</li>
<li>support a modified subset of XQUF in our core specs (while remaining fully compatible with XQUF).</li>
</ol>
<p>I believe 2. is more realistic. By providing a simplified syntax, we could tackle some of the shortcomings of XQUF, such as its verbosity, and seemingly unnecessary restrictions:</p>
<h3>XQUF: Verbosity</h3>
<p>The <em>Transform</em> expression (or <em>Copy Modify</em> expression, as it’s called in 3.0) has a cumbersome and wordy syntax for doing very trivial things:</p>
<pre><code class="language-xquery">copy $node := &lt;a&gt;&lt;b/&gt;&lt;/a&gt;
modify delete node $node/b
return $node
</code></pre>
<p>The 3.0 <em>Transform With</em> syntax is a bit simpler, it utilizes the context item:</p>
<pre><code class="language-xquery">&lt;a&gt;&lt;b/&gt;&lt;/a&gt; transform with {
  delete node ./b
}
</code></pre>
<p>It resulted from the BaseX <code>update</code> syntax…</p>
<pre><code class="language-xquery">&lt;a&gt;&lt;b/&gt;&lt;/a&gt; update {
  delete node ./b
}
</code></pre>
<p>…which comes with an ambiguity that forbids its unchanged adoption: <code>element update {}</code> could be both an element constructor and an update statement. I think that dropping the curly braces (and, optionally, using parentheses) would resolve this issue.</p>
<h3>XQUF: Restrictions</h3>
<p>The XQUF syntax is very powerful, but it has some restrictions that require the use of FLWOR expressions when addressing multiple nodes. For example, the following statement is illegal…</p>
<pre><code class="language-xquery">replace //village with &lt;village/&gt;
</code></pre>
<p>…if the target is not a single node, which means that you have to write…</p>
<pre><code class="language-xquery">for $v in //village
return replace $v with &lt;village/&gt;
</code></pre>
<p>…or…</p>
<pre><code class="language-xquery">(: only supported in BaseX :)
//village ! (replace . with &lt;village/&gt;)
</code></pre>
<p>I’m pretty sure it would be safe to drop the restriction, which also exists for other update expressions, such as <code>insert nodes NODES into SINGLE-NODE</code> or <code>rename node NODE as 'NAME'</code> (<code>delete nodes NODES</code> is legal). Allowing multiple targets would greatly reduce the number of iterations required within update blocks in practice.</p>
<h3>XQuery Update <em>light</em></h3>
<p>I think the new update syntax should meet the following requirements (among others):</p>
<ul>
<li>Compatible with the XQUF node semantics.</li>
<li>Similar syntax for supported input types.</li>
<li>Chaining of update operations.</li>
</ul>
<p>First, we would need to decide on a syntax that would be applicable to both maps/arrays and nodes. We could:</p>
<ol>
<li>Build on the proposal in <a href="https://github.com/qt4cg/qtspecs/pull/832">#832</a>, which introduces a new syntax for maps and arrays, and  extend it for nodes:</li>
</ol>
<pre><code class="language-xquery">update map   INPUT-MAP   { ... }
update array INPUT-ARRAY { ... }
update node  INPUT-NODE  { ... }
</code></pre>
<ol start="2">
<li>Build on XQUF 3.0:</li>
</ol>
<pre><code class="language-xquery">INPUT-MAP   transform with { ... }
INPUT-ARRAY transform with { ... }
INPUT-NODE  transform with { ... }
</code></pre>
<ol start="3">
<li>Build on BaseX (allowing multiple input items and chains):</li>
</ol>
<pre><code class="language-xquery">INPUT-MAPS   update (...) update (...)
INPUT-ARRAYS update (...) update (...)
INPUT-NODES  update (...) update (...)
</code></pre>
<p>Syntax 2. and 3. is challenging, as the type of the input can only be evaluated at time (and for XQUF it has to be determined statically whether an expression is an updating or non-updating).</p>
<p>As we currently have a proposal for 1., I will stick to that syntax, but allow an optional plural form for <code>map</code> and <code>array</code> (inspired by XQUF), and use chains. Within the the update block, we could now use the short syntax also for nodes without the <code>node</code>/<code>nodes</code> keywords:</p>
<pre><code class="language-xquery">update map $country-map {
  delete ??entry:city
},
update maps $country-maps update {
  rename ?entry:village as 'city'
},

update node $country-node {
  delete //city
},
update nodes $country-nodes {
  insert &lt;lakes/&gt; into .,
  insert &lt;mountains/&gt; into .
} {
  insert &lt;lake/&gt; into //lakes
)
</code></pre>
<h3>Semantics</h3>
<ul>
<li>Note that for XQUF update expressions it makes a difference whether multiple expressions are defined with the same block or in a subsequent block – which is why I think chains are essential.</li>
<li>Even though the syntax would be similar for node and map/array updates, the inherent semantics would differ a lot – which is something, however, users would not need to care about too much: Node updates would greatly rely on XQUF, whereas map/array updates would be based on the new proposal.</li>
</ul>
<p>I’m looking forward to everyone’s opinions.</p>
</div></details></div>
<div class="toot" id="created-1224"><h2>Issue #1224 created<span class="toot-id"> #created-1224</span></h2><div class="pubdate">18 May at 02:27:22 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1224">https://github.com/qt4cg/qtspecs/issues/1224</a></div><details><summary>Attribute priority for xsl:accumulator-rule</summary><div class="markup"><p>I propose that XSLT <code>xsl:accumulator-rule</code> be allowed to take attribute <code>priority</code>, to allow users to be more declarative in their accumulator rules. Even accumulators with two or three rules might require simple overshadowing: a default rule for the majority of nodes, with accommodation for certain exceptions. An explicitly declared priority rather than document order will allows users to better express their intentions, and processor-generated warnings about duplicate matches will be more meaningful.</p>
<p>Because the current rules stipulate that among multiple rules the last one in document order wins, I think that backward compatibility prevents us from using the default priority rules for templates (i.e., allotting -0.5, 0, 0.25 scores based on match pattern types). Rather, in this case, every accumulator rule is assumed to have priority 0, unless otherwise specified. If a node matches more than one rule of the same priority level, the last one wins. This simpler version of priority (assume zero, and if you know multiple matches will overlap, use <code>@priority</code>) is one that many developers have come to use for templates.</p>
</div></details></div>
<div class="toot" id="closed-1188"><h2>Issue #1188 closed<span class="toot-id"> #closed-1188</span></h2><div class="pubdate">18 May at 01:40:59 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1188">https://github.com/qt4cg/qtspecs/issues/1188</a></div><p>fn:hash: Editorial</p></div>
<div class="toot" id="created-1223"><h2>Pull request #1223 created<span class="toot-id"> #created-1223</span></h2><div class="pubdate">18 May at 01:38:17 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1223">https://github.com/qt4cg/qtspecs/pull/1223</a></div><details><summary>Minor: fixed URL</summary><div class="markup"><p>Fixes link to Unicode TR29</p>
</div></details></div>
<div class="toot" id="created-1222"><h2>Pull request #1222 created<span class="toot-id"> #created-1222</span></h2><div class="pubdate">18 May at 01:31:42 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1222">https://github.com/qt4cg/qtspecs/pull/1222</a></div><details><summary>1214: hash examples</summary><div class="markup"><p>addresses #1214</p>
</div></details></div>
<div class="toot" id="created-1221"><h2>Issue #1221 created<span class="toot-id"> #created-1221</span></h2><div class="pubdate">17 May at 13:40:14 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1221">https://github.com/qt4cg/qtspecs/issues/1221</a></div><details><summary>new function - fn:tail-recurse a function to allow users to hand roll their recursion and guarentee tail recursion.</summary><div class="markup"><p>Motivation:</p>
<ul>
<li>I as a user of XPath want to write a recursive function.</li>
<li>I write the function,</li>
<li>I run it,</li>
<li>it causes a stack overflow</li>
</ul>
<p>So,</p>
<ul>
<li>I don't believe tail recursion detection is part of the spec thus an implementation may not implement it</li>
<li>tail recursion detection I suspect is hard, and I suspect there are cases that are tail recursion that an implementation doesnt  detect</li>
</ul>
<p>Tail recursion is not an uncommon problem in other languages, in imperative languages I would simply implement the algorithm using a 'while' loop, creating the 'body' of the while loop is my problem, but once I've done it, I KNOW that in all implementations my algorithm will be executed tail recursively (imperative code is FULL of loops, stack overloads are not an issue).</p>
<p>An example</p>
<p>I want to implement a power function in C# I know how to write it recursively, but C# doesn't support tail recursion, so I have to turn it into a loop. I could do this in an ad hoc way using a while loop, but I could also write the loop once, and then ask the developer to pass in a function that defines the body of the loop</p>
<p>in C# that function could have the type (i.e. it takes a state and either returns a new state or null, a null would indicte the end of the 'loop')</p>
<p><code>State? recurse(State state)</code></p>
<p>and the library function that executes it have the signature:</p>
<p><code>State TailRecurse&lt;State&gt;(Func&lt;State,State?&gt; f, State state) </code></p>
<p>a complete example of how this would appear in C# would be:
(note C# has a nuance w.r.t. the higher kinded type '?' and so the signature of TailRecurse below is slightly weaker than the one above).</p>
<pre><code>var toPower3 = TailRecursion.Power2(3);
var result = TailRecursion.TailRecurse(toPower3, (0, 2));

Console.WriteLine(result.Value.Item2);

class TailRecursion
{
    // actually we want, but because of a quirk in C# around the '?' higher kinded type we have to write the signature symetrically (I think).
    //public static State TailRecurse&lt;State&gt;(Func&lt;State, State?&gt; f, State state)
    public static State TailRecurse&lt;State&gt;(Func&lt;State?,State?&gt; f, State state)
    {
        while (true)
        {
            var result = f(state);
            if (result == null)
            {
                return state;
            }
            state = result;
        }
    }

    public static Func&lt;(int,int)?,(int,int)?&gt; Power2(int n)
    {
        return powerAndX =&gt;
        {
            if (powerAndX.Value.Item1 &gt; n)
            {
                return null;
            }
            return (powerAndX.Value.Item1 + 1, powerAndX.Value.Item2 * powerAndX.Value.Item2);
        };
    }
}
</code></pre>
<p>in XSLT I could write this function</p>
<pre><code>&lt;xsl:function name="kooks:pow" as="xs:integer"&gt;
    &lt;xsl:param name="x" as ="xs:integer"/&gt;
    &lt;xsl:param name="n" as ="xs:integer"/&gt;
    &lt;xsl:choose&gt;
        &lt;xsl:when test="$n = 0"&gt;
            &lt;xsl:sequence select="$x"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
            &lt;xsl:sequence select="$x * kooks:pow($x,$n - 1)"/&gt;
        &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
&lt;/xsl:function&gt;
</code></pre>
<p>I know its tail recursive, but my environment may not for whatever reason detect it (I would hope it does, but I could be doing something much more complex, that IS tail recursive but the environment simply doesn't see it).</p>
<p>I can't write a loop in XPath etc, it doesnt exist, so I can't escape like I do in C# or scala, in F# (which also doesnt support while loops), I would have to write a function that I was sure F# detected as tail recursive and then path the 'body' of the while loop as a function.</p>
<p>in XSLT this could look like this (basically the same as the C# example)</p>
<p>here the C# signature
<code>State TailRecurse&lt;State&gt;(Func&lt;State,State?&gt; f, State state) </code>
has been translated by using <code>item()*</code> for state an <code>array(*)</code> for State?, where an empty array corresponds to null/none, and an array with 1 element corresponds to 'some' State.</p>
<p>This function IS tail recursive in a very simple way that I think all implementations would detect as such, and thus (if it does) I can pass any function I like and be confident it is processed tail recursively - I can of course do this now, I use saxon, (even though I'm wrestling with it to detect tail recursion for some bizarre reason which is probably my fault) I think it would ideally be a library function and (using a loop) allow non tail recursive environments to support tail recursion, or allow me to simply do the detection myself.</p>
<pre><code>    &lt;xsl:function name="kooks:tailRecurse"&gt;
        &lt;xsl:param name="unfolder" as="function(item()*) as array(*)"/&gt;
        &lt;xsl:param name="state" as="item()*"/&gt;
        &lt;xsl:variable name="newState" select="$unfolder($state)"/&gt;
        &lt;xsl:choose&gt;
            &lt;!-- loop returns null/none - end of recurstion --&gt;
            &lt;xsl:when test="array:size($newState) = 0"&gt;
                &lt;xsl:sequence select="$state"/&gt;
            &lt;/xsl:when&gt;
            &lt;!-- else, unpack the state and loop again --&gt;
            &lt;xsl:otherwise&gt;
                &lt;xsl:sequence select="kooks:tailRecurse($unfolder,array:get($newState,1))"/&gt;
            &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;        
    &lt;/xsl:function&gt;

</code></pre>
<p>For environments that don't do tail recursion detection, they can simple implement the analogous code to the C# example in their implementation i.e. map it to a while loop.</p>
<p>In both cases I think this is hopefully trivial for the implementor of the language.</p>
<p>Here's a complete example, with tailRecurse defined as above, that would guarentee (in an environment that detected it correctly) that any passed function is processed.</p>
<pre><code>&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:array="http://www.w3.org/2005/xpath-functions/array"
    xmlns:map="http://www.w3.org/2005/xpath-functions/map"
    exclude-result-prefixes="xs"
    version="3.0"
    xmlns:kooks="http://www.kookerella.com"&gt;
    
    &lt;!-- (state -&gt; Maybe state) -&gt; state -&gt; state --&gt; 
    &lt;xsl:function name="kooks:tailRecurse"&gt;
        &lt;xsl:param name="unfolder" as="function(item()*) as array(*)"/&gt;
        &lt;xsl:param name="state" as="item()*"/&gt;
        &lt;xsl:variable name="newState" select="$unfolder($state)"/&gt;
        &lt;xsl:choose&gt;
            &lt;!-- loop returns null/none - end of recurstion --&gt;
            &lt;xsl:when test="array:size($newState) = 0"&gt;
                &lt;xsl:sequence select="$state"/&gt;
            &lt;/xsl:when&gt;
            &lt;!-- else, unpack the state and loop again --&gt;
            &lt;xsl:otherwise&gt;
                &lt;xsl:sequence select="kooks:tailRecurse($unfolder,array:get($newState,1))"/&gt;
            &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;        
    &lt;/xsl:function&gt;
    
    &lt;xsl:function name="kooks:powUnfolder" as="function(item()*) as array(*)"&gt;
        &lt;xsl:param name="x" as="xs:integer"/&gt;
        &lt;xsl:param name="n" as="xs:integer"/&gt;
        &lt;xsl:sequence select="function($state) {
                if (map:get($state,'power') &gt;= $n)
                (: we're done so return null/none :)
                then array {}
                else
                (: else calculate the next power and loop again :)
                    let $newState := map { 
                        'power': map:get($state,'power') + 1,
                        'result': map:get($state,'result') * $x
                        }
                    return array { $newState }
            }"/&gt;
    &lt;/xsl:function&gt;
    
    &lt;xsl:template match="/"&gt;
        &lt;twoToThePower4&gt;
            &lt;xsl:variable name="seed" select="map { 'power':0,'result':1 }"/&gt;
            &lt;xsl:sequence select="map:get(kooks:tailRecurse(kooks:powUnfolder(2,4),$seed),'result')"/&gt;
        &lt;/twoToThePower4&gt;
    &lt;/xsl:template&gt;    
&lt;/xsl:stylesheet&gt;
</code></pre>
<p>I suspect these lines are not obvious.</p>
<pre><code>            &lt;xsl:variable name="seed" select="map { 'power':0,'result':1 }"/&gt;
            &lt;xsl:sequence select="map:get(kooks:tailRecurse(kooks:powUnfolder(2,4),$seed),'result')"/&gt;
</code></pre>
<p>The first line says anything to the power 0 is 1, the second line says, I want the 'result of 2 to the power 4.</p>
<p>Note its VERY similar to xsl:iterate, but that requires an sequence to drive it, this is just general recursion.</p>
</div></details></div>
<div class="toot" id="closed-73"><h2>Issue #73 closed<span class="toot-id"> #closed-73</span></h2><div class="pubdate">15 May at 11:12:10 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/73">https://github.com/qt4cg/qtspecs/issues/73</a></div><p>Split a string by graphemes</p></div>
<div class="toot" id="created-1220"><h2>Pull request #1220 created<span class="toot-id"> #created-1220</span></h2><div class="pubdate">15 May at 09:32:56 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1220">https://github.com/qt4cg/qtspecs/pull/1220</a></div><details><summary>73 copy&amp;paste typo in fn:graphemes (combining diaeresis should be ZWJ)</summary><div class="markup"><p>I wonder which font I need to use in order to see U+1F476 U+200D U+1F6D1 as a single grapheme. When I naively put the character sequence into an HTML page, the two glyphs will be rendered individually. How can we make sure that the grapheme will be rendered as intended for most people when they read the spec?</p>
</div></details></div>
<div class="toot" id="created-1219"><h2>Pull request #1219 created<span class="toot-id"> #created-1219</span></h2><div class="pubdate">14 May at 20:41:37 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1219">https://github.com/qt4cg/qtspecs/pull/1219</a></div><details><summary>1218 Drop use of union(A,B) syntax</summary><div class="markup"><p>Fix #1218</p>
</div></details></div>
<div class="toot" id="created-1218"><h2>Issue #1218 created<span class="toot-id"> #created-1218</span></h2><div class="pubdate">14 May at 20:18:12 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1218">https://github.com/qt4cg/qtspecs/issues/1218</a></div><details><summary>Residual references to union(A, B)</summary><div class="markup"><p>The XQuery spec has 10 uses of the obsolete syntax <code>union(A, B)</code>, and the F&amp;O spec has another 6. XSLT has 7, and XDM has two.</p>
</div></details></div>
<div class="toot" id="minutes-05-14"><h2>QT4 CG meeting 077 draft minutes<span class="toot-id"> #minutes-05-14</span></h2><div class="pubdate">14 May at 18:00:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2024/05-14">https://qt4cg.org/meeting/minutes/2024/05-14</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="created-1217"><h2>Pull request #1217 created<span class="toot-id"> #created-1217</span></h2><div class="pubdate">14 May at 17:58:44 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1217">https://github.com/qt4cg/qtspecs/pull/1217</a></div><details><summary>1207 Allow numeric predicates when filtering arrays</summary><div class="markup"><p>Fix #1207</p>
<p>Also a minor change: <code>$V[23, "fred"]</code> now throws FORG0006 rather than XPTY0004. This keeps it compatible with 3.1 (in case anyone is catching the errors), and is more uniform: it seems unreasonable for <code>$V[23, "fred"]</code> and <code>$V["fred", 23]</code> to throw different errors.</p>
</div></details></div>
<div class="toot" id="created-1216"><h2>Issue #1216 created<span class="toot-id"> #created-1216</span></h2><div class="pubdate">14 May at 16:37:14 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1216">https://github.com/qt4cg/qtspecs/issues/1216</a></div><details><summary>Detailed comments on math:e, sinh(), cosh(), tanh()</summary><div class="markup"><p>I should have made these comments before we accepted the proposal, but it's only minor details.</p>
<p>In the example given for <code>math:e</code>, the explanation of the example as a compound interest calculation seems a bit simplistic. There are all sorts of assumptions here about the initial investment, the frequency at which interest is calculated, etc. It might be better just to give the expression and the result and not attempt an interpretation.</p>
<p>According to IEEE 754-2008 table 9.1, <code>sinh()</code> can produce overflow or underflow, <code>cosh()</code> can produce overflow, and <code>tanh()</code> can produce underflow. We seem to be catering for exceptions that cannot occur?</p>
<p>The example results should perhaps be tagged as approximate to ensure that they pass automated testing.</p>
<p>We should perhaps be referencing IEEE 754-2019 (though I'm reluctant to purchase a copy...)</p>
</div></details></div>
<div class="toot" id="closed-1195"><h2>Issue #1195 closed<span class="toot-id"> #closed-1195</span></h2><div class="pubdate">14 May at 16:31:09 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1195">https://github.com/qt4cg/qtspecs/issues/1195</a></div><p>Hash Function: CRC-32</p></div>
<div class="toot" id="closed-1206"><h2>Issue #1206 closed<span class="toot-id"> #closed-1206</span></h2><div class="pubdate">14 May at 16:31:08 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1206">https://github.com/qt4cg/qtspecs/pull/1206</a></div><p>1195 Hash Function: CRC-32</p></div>
<div class="toot" id="closed-1196"><h2>Issue #1196 closed<span class="toot-id"> #closed-1196</span></h2><div class="pubdate">14 May at 16:28:08 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1196">https://github.com/qt4cg/qtspecs/issues/1196</a></div><p>Math Functions: `math:e`, `math:sinh`, `math:cosh`, `math:tanh`</p></div>
<div class="toot" id="closed-1205"><h2>Issue #1205 closed<span class="toot-id"> #closed-1205</span></h2><div class="pubdate">14 May at 16:28:06 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1205">https://github.com/qt4cg/qtspecs/pull/1205</a></div><p>1196 Math Functions: math:e, math:sinh, math:cosh, math:tanh</p></div>
<div class="toot" id="closed-1204"><h2>Issue #1204 closed<span class="toot-id"> #closed-1204</span></h2><div class="pubdate">14 May at 16:24:47 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1204">https://github.com/qt4cg/qtspecs/pull/1204</a></div><p>1203 Define out-of-range conditions in CSV get function</p></div>
<div class="toot" id="closed-1203"><h2>Issue #1203 closed<span class="toot-id"> #closed-1203</span></h2><div class="pubdate">14 May at 16:24:47 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1203">https://github.com/qt4cg/qtspecs/issues/1203</a></div><p>CSV parsing: in call of get($R, $Z), what if $R is out of range</p></div>
<div class="toot" id="closed-1215"><h2>Issue #1215 closed<span class="toot-id"> #closed-1215</span></h2><div class="pubdate">14 May at 16:24:19 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1215">https://github.com/qt4cg/qtspecs/pull/1215</a></div><p>Fix ID/IDREF typo</p></div>
<div class="toot" id="created-1215"><h2>Pull request #1215 created<span class="toot-id"> #created-1215</span></h2><div class="pubdate">14 May at 16:24:13 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1215">https://github.com/qt4cg/qtspecs/pull/1215</a></div><details><summary>Fix ID/IDREF typo</summary><div class="markup"><p>I'm not sure how this slipped past the PR build checks...</p>
</div></details></div>
<div class="toot" id="created-1214"><h2>Issue #1214 created<span class="toot-id"> #created-1214</span></h2><div class="pubdate">14 May at 16:21:56 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1214">https://github.com/qt4cg/qtspecs/issues/1214</a></div><details><summary>fn:hash, CRC-32: Describe output</summary><div class="markup"><p>In the <a href="https://qt4cg.org/meeting/minutes/2024/05-14.html">QT4 CG Meeting 077</a> it was suggested that the binary output of the newly added <code>CRC-32</code> algorithm should be further described.</p>
</div></details></div>
<div class="toot" id="closed-1198"><h2>Issue #1198 closed<span class="toot-id"> #closed-1198</span></h2><div class="pubdate">14 May at 16:17:35 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1198">https://github.com/qt4cg/qtspecs/pull/1198</a></div><p>1189 distinct document order</p></div></div><p>See 2395
            more statuses in yearly archives.</p></article></main></body></html>